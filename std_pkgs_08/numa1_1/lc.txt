
Line coverage for $root.$pkgs.not_ieee.std_logic_1164:

Coverage for source: not_ieee/2008/std_logic_1164-body.vhdl

           0 sequence             86       if (s'length = 1) then 
           0 if                   86                              return s(s'low);
                                  87       else
                                  88         
           0 else                 88         for i in s'range loop
                                  89           
           0 loop_body            89           result := resolution_table(result, s(i));
                                  90         end loop;
                                  91       end if;
                                  92       
           0 reconvergence        92       return result;
                                  93     end function resolved
           0 sequence            160       return (and_table(l, r));
                                 161     end function "and"
           0 sequence            165       return (not_table (and_table(l, r)));
                                 166     end function "nand"
           0 sequence            170       return (or_table(l, r));
                                 171     end function "or"
           0 sequence            175       return (not_table (or_table(l, r)));
                                 176     end function "nor"
          78 sequence            180       return (xor_table(l, r));
                                 181     end function "xor"
           0 sequence            185       return not_table(xor_table(l, r));
                                 186     end function "xnor"
           0 sequence            190       return (not_table(l));
                                 191     end function "not"
           0 sequence            201       if (l'length /= r'length) then
                                 202         
           0 if                  202         assert false
                                 203           report "STD_LOGIC_1164.""and"": "
                                 204           & "arguments of overloaded 'and' operator are not of the same length"
                                 205           severity failure;
                                 206       else
                                 207         
           0 else                207         for i in result'range loop
                                 208           
           0 loop_body           208           result(i) := and_table (lv(i), rv(i));
                                 209         end loop;
                                 210       end if;
                                 211       
           0 reconvergence       211       return result;
                                 212     end function "and"
           0 sequence            221       if (l'length /= r'length) then
                                 222         
           0 if                  222         assert false
                                 223           report "STD_LOGIC_1164.""nand"": "
                                 224           & "arguments of overloaded 'nand' operator are not of the same length"
                                 225           severity failure;
                                 226       else
                                 227         
           0 else                227         for i in result'range loop
                                 228           
           0 loop_body           228           result(i) := not_table(and_table (lv(i), rv(i)));
                                 229         end loop;
                                 230       end if;
                                 231       
           0 reconvergence       231       return result;
                                 232     end function "nand"
           0 sequence            241       if (l'length /= r'length) then
                                 242         
           0 if                  242         assert false
                                 243           report "STD_LOGIC_1164.""or"": "
                                 244           & "arguments of overloaded 'or' operator are not of the same length"
                                 245           severity failure;
                                 246       else
                                 247         
           0 else                247         for i in result'range loop
                                 248           
           0 loop_body           248           result(i) := or_table (lv(i), rv(i));
                                 249         end loop;
                                 250       end if;
                                 251       
           0 reconvergence       251       return result;
                                 252     end function "or"
           0 sequence            261       if (l'length /= r'length) then
                                 262         
           0 if                  262         assert false
                                 263           report "STD_LOGIC_1164.""nor"": "
                                 264           & "arguments of overloaded 'nor' operator are not of the same length"
                                 265           severity failure;
                                 266       else
                                 267         
           0 else                267         for i in result'range loop
                                 268           
           0 loop_body           268           result(i) := not_table(or_table (lv(i), rv(i)));
                                 269         end loop;
                                 270       end if;
                                 271       
           0 reconvergence       271       return result;
                                 272     end function "nor"
           0 sequence            281       if (l'length /= r'length) then
                                 282         
           0 if                  282         assert false
                                 283           report "STD_LOGIC_1164.""xor"": "
                                 284           & "arguments of overloaded 'xor' operator are not of the same length"
                                 285           severity failure;
                                 286       else
                                 287         
           0 else                287         for i in result'range loop
                                 288           
           0 loop_body           288           result(i) := xor_table (lv(i), rv(i));
                                 289         end loop;
                                 290       end if;
                                 291       
           0 reconvergence       291       return result;
                                 292     end function "xor"
           0 sequence            301       if (l'length /= r'length) then
                                 302         
           0 if                  302         assert false
                                 303           report "STD_LOGIC_1164.""xnor"": "
                                 304           & "arguments of overloaded 'xnor' operator are not of the same length"
                                 305           severity failure;
                                 306       else
                                 307         
           0 else                307         for i in result'range loop
                                 308           
           0 loop_body           308           result(i) := not_table(xor_table (lv(i), rv(i)));
                                 309         end loop;
                                 310       end if;
                                 311       
           0 reconvergence       311       return result;
                                 312     end function "xnor"
           0 sequence            320       for i in result'range loop
                                 321         
           0 loop_body           321         result(i) := not_table(lv(i));
                                 322       end loop;
                                 323       
           0 reconvergence       323       return result;
                                 324     end function "not"
           0 sequence            335       for i in result'range loop
                                 336         
           0 loop_body           336         result(i) := and_table (lv(i), r);
                                 337       end loop;
                                 338       
           0 reconvergence       338       return result;
                                 339     end function "and"
           0 sequence            347       for i in result'range loop
                                 348         
           0 loop_body           348         result(i) := and_table (l, rv(i));
                                 349       end loop;
                                 350       
           0 reconvergence       350       return result;
                                 351     end function "and"
           0 sequence            362       for i in result'range loop
                                 363         
           0 loop_body           363         result(i) := not_table(and_table (lv(i), r));
                                 364       end loop;
                                 365       
           0 reconvergence       365       return result;
                                 366     end function "nand"
           0 sequence            374       for i in result'range loop
                                 375         
           0 loop_body           375         result(i) := not_table(and_table (l, rv(i)));
                                 376       end loop;
                                 377       
           0 reconvergence       377       return result;
                                 378     end function "nand"
           0 sequence            389       for i in result'range loop
                                 390         
           0 loop_body           390         result(i) := or_table (lv(i), r);
                                 391       end loop;
                                 392       
           0 reconvergence       392       return result;
                                 393     end function "or"
           0 sequence            401       for i in result'range loop
                                 402         
           0 loop_body           402         result(i) := or_table (l, rv(i));
                                 403       end loop;
                                 404       
           0 reconvergence       404       return result;
                                 405     end function "or"
           0 sequence            416       for i in result'range loop
                                 417         
           0 loop_body           417         result(i) := not_table(or_table (lv(i), r));
                                 418       end loop;
                                 419       
           0 reconvergence       419       return result;
                                 420     end function "nor"
           0 sequence            428       for i in result'range loop
                                 429         
           0 loop_body           429         result(i) := not_table(or_table (l, rv(i)));
                                 430       end loop;
                                 431       
           0 reconvergence       431       return result;
                                 432     end function "nor"
           0 sequence            443       for i in result'range loop
                                 444         
           0 loop_body           444         result(i) := xor_table (lv(i), r);
                                 445       end loop;
                                 446       
           0 reconvergence       446       return result;
                                 447     end function "xor"
           0 sequence            455       for i in result'range loop
                                 456         
           0 loop_body           456         result(i) := xor_table (l, rv(i));
                                 457       end loop;
                                 458       
           0 reconvergence       458       return result;
                                 459     end function "xor"
           0 sequence            470       for i in result'range loop
                                 471         
           0 loop_body           471         result(i) := not_table(xor_table (lv(i), r));
                                 472       end loop;
                                 473       
           0 reconvergence       473       return result;
                                 474     end function "xnor"
           0 sequence            482       for i in result'range loop
                                 483         
           0 loop_body           483         result(i) := not_table(xor_table (l, rv(i)));
                                 484       end loop;
                                 485       
           0 reconvergence       485       return result;
                                 486     end function "xnor"
           0 sequence            494       for i in l'reverse_range loop
                                 495         
           0 loop_body           495         result := and_table (l(i), result);
                                 496       end loop;
                                 497       
           0 reconvergence       497       return result;
                                 498     end function "and"
           0 sequence            506       for i in l'reverse_range loop
                                 507         
           0 loop_body           507         result := and_table (l(i), result);
                                 508       end loop;
                                 509       
           0 reconvergence       509       return not_table(result);
                                 510     end function "nand"
           0 sequence            518       for i in l'reverse_range loop
                                 519         
           0 loop_body           519         result := or_table (l(i), result);
                                 520       end loop;
                                 521       
           0 reconvergence       521       return result;
                                 522     end function "or"
           0 sequence            530       for i in l'reverse_range loop
                                 531         
           0 loop_body           531         result := or_table (l(i), result);
                                 532       end loop;
                                 533       
           0 reconvergence       533       return not_table(result);
                                 534     end function "nor"
           0 sequence            542       for i in l'reverse_range loop
                                 543         
           0 loop_body           543         result := xor_table (l(i), result);
                                 544       end loop;
                                 545       
           0 reconvergence       545       return result;
                                 546     end function "xor"
           0 sequence            554       for i in l'reverse_range loop
                                 555         
           0 loop_body           555         result := xor_table (l(i), result);
                                 556       end loop;
                                 557       
           0 reconvergence       557       return not_table(result);
                                 558     end function "xnor"
           0 sequence            573       if r >= 0 then
                                 574         
           0 if                  574         result(1 to l'length - r) := lv(r + 1 to l'length);
                                 575       else
                                 576         
           0 else                576         result := l srl -r;
                                 577       end if;
                                 578       
           0 reconvergence       578       return result;
                                 579     end function "sll"
           0 sequence            590       if r >= 0 then
                                 591         
           0 if                  591         result(r + 1 to l'length) := lv(1 to l'length - r);
                                 592       else
                                 593         
           0 else                593         result := l sll -r;
                                 594       end if;
                                 595       
           0 reconvergence       595       return result;
                                 596     end function "srl"
           0 sequence            608       if r >= 0 then
                                 609         
           0 if                  609         result(1 to l'length - rm)            := lv(rm + 1 to l'length);
                                 610         result(l'length - rm + 1 to l'length) := lv(1 to rm);
                                 611       else
                                 612         
           0 else                612         result := l ror -r;
                                 613       end if;
                                 614       
           0 reconvergence       614       return result;
                                 615     end function "rol"
           0 sequence            627       if r >= 0 then
                                 628         
           0 if                  628         result(rm + 1 to l'length) := lv(1 to l'length - rm);
                                 629         result(1 to rm)            := lv(l'length - rm + 1 to l'length);
                                 630       else
                                 631         
           0 else                631         result := l rol -r;
                                 632       end if;
                                 633       
           0 reconvergence       633       return result;
                                 634     end function "ror"
           0 sequence            716       case s is
                                 717         when '0' | 'L' => 
           0 case_item           717                           return ('0');
                                 718         when '1' | 'H' => 
           0 case_item           718                           return ('1');
                                 719         when others    => 
           0 case_item           719                           return xmap;
                                 720       end case;
                                 721     end function To_bit
           0 sequence            729       for i in result'range loop
                                 730         
           0 loop_body           730         case sv(i) is
                                 731           when '0' | 'L' => 
           0 reconvergence       736       return result;
                                 737     end function To_bitvector
           0 case_item           731                             result(i) := '0';
                                 732           when '1' | 'H' => 
           0 case_item           732                             result(i) := '1';
                                 733           when others    => 
           0 case_item           733                             result(i) := xmap;
                                 734         end case;
                                 735       end loop;
                                 736       
           0 sequence            741       case b is
                                 742         when '0' => 
           0 case_item           742                     return '0';
                                 743         when '1' => 
           0 case_item           743                     return '1';
                                 744       end case;
                                 745     end function To_StdULogic
           0 sequence            753       for i in result'range loop
                                 754         
           0 loop_body           754         case bv(i) is
                                 755           when '0' => 
           0 reconvergence       759       return result;
                                 760     end function To_StdLogicVector
           0 case_item           755                       result(i) := '0';
                                 756           when '1' => 
           0 case_item           756                       result(i) := '1';
                                 757         end case;
                                 758       end loop;
                                 759       
           0 sequence            768       for i in result'range loop
                                 769         
           0 loop_body           769         result(i) := sv(i);
                                 770       end loop;
                                 771       
           0 reconvergence       771       return result;
                                 772     end function To_StdLogicVector
           0 sequence            780       for i in result'range loop
                                 781         
           0 loop_body           781         case bv(i) is
                                 782           when '0' => 
           0 reconvergence       786       return result;
                                 787     end function To_StdULogicVector
           0 case_item           782                       result(i) := '0';
                                 783           when '1' => 
           0 case_item           783                       result(i) := '1';
                                 784         end case;
                                 785       end loop;
                                 786       
           0 sequence            795       for i in result'range loop
                                 796         
           0 loop_body           796         result(i) := sv(i);
                                 797       end loop;
                                 798       
           0 reconvergence       798       return result;
                                 799     end function To_StdULogicVector
          25 sequence            813       for I in RESULT'range loop
                                 814         
         200 loop_body           814         case XS(I) is
                                 815           when '0' | 'L' => 
         175 case_item           815                             RESULT(I)   := '0';
                                 816           when '1' | 'H' => 
           0 case_item           816                             RESULT(I)   := '1';
                                 817           when others    => 
          25 case_item           817                             BAD_ELEMENT := true;
                                 818         end case;
                                 819       end loop;
                                 820       
          25 if                  821         for I in RESULT'range loop
                                 822           
         200 loop_body           822           RESULT(I) := xmap;              -- standard fixup
                                 823         end loop;
                                 824       end if;
                                 825       
          25 reconvergence       825       return RESULT;
                                 826     end function TO_01
           0 implicit_else       820       if BAD_ELEMENT then
                                 821         
           0 sequence            830       case s is
                                 831         when '0' | 'L' => 
           0 case_item           831                           RETURN '0';
                                 832         when '1' | 'H' => 
           0 case_item           832                           RETURN '1';
                                 833         when others    => 
           0 case_item           833                           return xmap;
                                 834       end case;
                                 835     end function TO_01
           0 sequence            843       for I in RESULT'range loop
                                 844         
           0 loop_body           844         case XS(I) is
                                 845           when '0' => 
           0 reconvergence       849       return RESULT;
                                 850     end function TO_01
           0 case_item           845                       RESULT(I) := '0';
                                 846           when '1' => 
           0 case_item           846                       RESULT(I) := '1';
                                 847         end case;
                                 848       end loop;
                                 849       
           0 sequence            854       case s is
                                 855         when '0' => 
           0 case_item           855                     RETURN '0';
                                 856         when '1' => 
           0 case_item           856                     RETURN '1';
                                 857       end case;
                                 858     end function TO_01
           0 sequence            866       for i in result'range loop
                                 867         
           0 loop_body           867         result(i) := cvt_to_x01 (sv(i));
                                 868       end loop;
                                 869       
           0 reconvergence       869       return result;
                                 870     end function To_X01
           0 sequence            874       return (cvt_to_x01(s));
                                 875     end function To_X01
           0 sequence            881       for i in result'range loop
                                 882         
           0 loop_body           882         case bv(i) is
                                 883           when '0' => 
           0 reconvergence       887       return result;
                                 888     end function To_X01
           0 case_item           883                       result(i) := '0';
                                 884           when '1' => 
           0 case_item           884                       result(i) := '1';
                                 885         end case;
                                 886       end loop;
                                 887       
           0 sequence            892       case b is
                                 893         when '0' => 
           0 case_item           893                     return('0');
                                 894         when '1' => 
           0 case_item           894                     return('1');
                                 895       end case;
                                 896     end function To_X01
           0 sequence            904       for i in result'range loop
                                 905         
           0 loop_body           905         result(i) := cvt_to_x01z (sv(i));
                                 906       end loop;
                                 907       
           0 reconvergence       907       return result;
                                 908     end function To_X01Z
           0 sequence            912       return (cvt_to_x01z(s));
                                 913     end function To_X01Z
           0 sequence            919       for i in result'range loop
                                 920         
           0 loop_body           920         case bv(i) is
                                 921           when '0' => 
           0 reconvergence       925       return result;
                                 926     end function To_X01Z
           0 case_item           921                       result(i) := '0';
                                 922           when '1' => 
           0 case_item           922                       result(i) := '1';
                                 923         end case;
                                 924       end loop;
                                 925       
           0 sequence            930       case b is
                                 931         when '0' => 
           0 case_item           931                     return('0');
                                 932         when '1' => 
           0 case_item           932                     return('1');
                                 933       end case;
                                 934     end function To_X01Z
           0 sequence            942       for i in result'range loop
                                 943         
           0 loop_body           943         result(i) := cvt_to_ux01 (sv(i));
                                 944       end loop;
                                 945       
           0 reconvergence       945       return result;
                                 946     end function To_UX01
           0 sequence            950       return (cvt_to_ux01(s));
                                 951     end function To_UX01
           0 sequence            957       for i in result'range loop
                                 958         
           0 loop_body           958         case bv(i) is
                                 959           when '0' => 
           0 reconvergence       963       return result;
                                 964     end function To_UX01
           0 case_item           959                       result(i) := '0';
                                 960           when '1' => 
           0 case_item           960                       result(i) := '1';
                                 961         end case;
                                 962       end loop;
                                 963       
           0 sequence            968       case b is
                                 969         when '0' => 
           0 case_item           969                     return('0');
                                 970         when '1' => 
           0 case_item           970                     return('1');
                                 971       end case;
                                 972     end function To_UX01
           0 sequence            976       return l = '1' or l = 'H';
                                 977     end function "??"
           0 sequence            984       return (s'event and (To_X01(s) = '1') and
                                 985               (To_X01(s'last_value) = '0'));
                                 986     end function rising_edge
           0 sequence            990       return (s'event and (To_X01(s) = '0') and
                                 991               (To_X01(s'last_value) = '1'));
                                 992     end function falling_edge
           0 sequence            999       for i in s'range loop
                                1000         
           0 loop_body          1000         case s(i) is
                                1001           when 'U' | 'X' | 'Z' | 'W' | '-' => 
           0 reconvergence      1005       return false;
                                1006     end function Is_X
           0 case_item          1001                                               return true;
                                1002           when others                      => 
           0 case_item          1002                                               null;
                                1003         end case;
                                1004       end loop;
                                1005       
           0 sequence           1010       case s is
                                1011         when 'U' | 'X' | 'Z' | 'W' | '-' => 
           0 case_item          1011                                             return true;
                                1012         when others                      => 
           0 case_item          1012                                             null;
                                1013       end case;
                                1014       
           0 reconvergence      1014       return false;
                                1015     end function Is_X
           0 sequence           1577         l1 := To_X01Z(l);
                                1578         r1 := To_X01Z(r);
                                1579         
           0 if                 1580             return result;
                                1581         end if;
                                1582         
           0 implicit_else      1579         if l1 = 'Z' or l1 = 'X' then
                                1580             
           0 if                 1583             return result;
                                1584         end if;
                                1585         
           0 implicit_else      1582         if r1 = 'Z' or r1 = 'X' then
                                1583             
           0 if                 1585                       result := '1'; end if;
                                1586         
           0 implicit_else      1585         if l = r then 
           0 reconvergence      1586         return result;
                                1587       end function "?="
           0 sequence           1596         l1 := To_X01Z(l);
                                1597         r1 := To_X01Z(r);
                                1598         
           0 if                 1599             return result;
                                1600         end if;
                                1601         
           0 implicit_else      1598         if l1 = 'Z' or l1 = 'X' then
                                1599             
           0 if                 1602             return result;
                                1603         end if;
                                1604         
           0 implicit_else      1601         if r1 = 'Z' or r1 = 'X' then
                                1602             
           0 if                 1604                        result := '1'; end if;
                                1605         
           0 implicit_else      1604         if l /= r then 
           0 reconvergence      1605         return result;
                                1606       end function "?/="
           0 sequence           1028       if value (value'left) = 'Z' then
                                1029         
           0 if                 1029         pad := (others => 'Z');
                                1030       else
                                1031         
           0 else               1031         pad := (others => '0');
                                1032       end if;
                                1033       
           0 reconvergence      1033       padded_value := pad & value;
                                1034       for i in 1 to result_length loop
                                1035         
           0 loop_body          1035         tri := To_X01Z(padded_value(3*i-2 to 3*i));
                                1036         case tri is
                                1037           when o"0"   => 
           0 case_item          1038                          result(i) := '1';
                                1039           when o"2"   => 
           0 case_item          1043                          result(i) := '6';
                                1044           when o"7"   => 
           0 case_item          1044                          result(i) := '7';
                                1045           when "ZZZ"  => 
           0 case_item          1045                          result(i) := 'Z';
                                1046           when others => 
           0 reconvergence      1049       return result;
                                1050     end function TO_OSTRING
           0 case_item          1037                          result(i) := '0';
                                1038           when o"1"   => 
           0 case_item          1039                          result(i) := '2';
                                1040           when o"3"   => 
           0 case_item          1040                          result(i) := '3';
                                1041           when o"4"   => 
           0 case_item          1041                          result(i) := '4';
                                1042           when o"5"   => 
           0 case_item          1042                          result(i) := '5';
                                1043           when o"6"   => 
           0 case_item          1046                          result(i) := 'X';
                                1047         end case;
                                1048       end loop;
                                1049       
           0 sequence           1059       if value (value'left) = 'Z' then
                                1060         
           0 if                 1060         pad := (others => 'Z');
                                1061       else
                                1062         
           0 else               1062         pad := (others => '0');
                                1063       end if;
                                1064       
           0 reconvergence      1064       padded_value := pad & value;
                                1065       for i in 1 to result_length loop
                                1066         
           0 loop_body          1066         quad := To_X01Z(padded_value(4*i-3 to 4*i));
                                1067         case quad is
                                1068           when x"0"   => 
           0 case_item          1068                          result(i) := '0';
                                1069           when x"1"   => 
           0 case_item          1069                          result(i) := '1';
                                1070           when x"2"   => 
           0 case_item          1075                          result(i) := '7';
                                1076           when x"8"   => 
           0 case_item          1076                          result(i) := '8';
                                1077           when x"9"   => 
           0 case_item          1077                          result(i) := '9';
                                1078           when x"A"   => 
           0 case_item          1078                          result(i) := 'A';
                                1079           when x"B"   => 
           0 case_item          1079                          result(i) := 'B';
                                1080           when x"C"   => 
           0 case_item          1080                          result(i) := 'C';
                                1081           when x"D"   => 
           0 case_item          1081                          result(i) := 'D';
                                1082           when x"E"   => 
           0 case_item          1082                          result(i) := 'E';
                                1083           when x"F"   => 
           0 case_item          1083                          result(i) := 'F';
                                1084           when "ZZZZ" => 
           0 case_item          1084                          result(i) := 'Z';
                                1085           when others => 
           0 reconvergence      1088       return result;
                                1089     end function TO_HSTRING
           0 case_item          1070                          result(i) := '2';
                                1071           when x"3"   => 
           0 case_item          1071                          result(i) := '3';
                                1072           when x"4"   => 
           0 case_item          1072                          result(i) := '4';
                                1073           when x"5"   => 
           0 case_item          1073                          result(i) := '5';
                                1074           when x"6"   => 
           0 case_item          1074                          result(i) := '6';
                                1075           when x"7"   => 
           0 case_item          1085                          result(i) := 'X';
                                1086         end case;
                                1087       end loop;
                                1088       
           0 sequence           1129       VALUE := 'U';                       -- initialize to a "U"
                                1130       skip_whitespace (L);
                                1131       read (L, c, readOk);
                                1132       if not readOk then
                                1133         
           0 if                 1133         GOOD := false;
                                1134       else
                                1135         
           0 else               1135         if char_to_MVL9plus(c) = error then
                                1136           
           0 if                 1136           GOOD := false;
                                1137         else
                                1138           
           0 else               1138           VALUE := char_to_MVL9(c);
                                1139           GOOD  := true;
                                1140         end if;
                                1141       end if;
                                1142     end procedure READ
           0 sequence           1195       VALUE := 'U';                       -- initialize to a "U"
                                1196       skip_whitespace (L);
                                1197       read (L, c, readOk);
                                1198       if not readOk then
                                1199         
           0 if                 1199         report "STD_LOGIC_1164.READ(STD_ULOGIC) "
                                1200           & "End of string encountered"
                                1201           severity error;
                                1202         return;
                                1203       elsif 
           0 sequence           1203             char_to_MVL9plus(c) = error then
                                1204         
           0 elsif              1204         report
                                1205           "STD_LOGIC_1164.READ(STD_ULOGIC) Error: Character '" &
                                1206           c & "' read, expected STD_ULOGIC literal."
                                1207           severity error;
                                1208       else
                                1209         
           0 else               1209         VALUE := char_to_MVL9(c);
                                1210       end if;
                                1211     end procedure READ
           0 sequence           1152       VALUE := (VALUE'range => 'U'); -- initialize to a "U"
                                1153       skip_whitespace (L);
                                1154       if VALUE'length > 0 then
                                1155         
           0 if                 1155         read (L, c, readOk);
                                1156         i := 0;
                                1157         GOOD := true;
                                1158         while 
           0 sequence           1158               i < VALUE'length loop
                                1159           
           0 loop_body          1159           if not readOk then     -- Bail out if there was a bad read
                                1160             
           0 if                 1160             GOOD := false;
                                1161             return;
                                1162           elsif 
           0 sequence           1162                 c = '_' then
                                1163             
           0 elsif              1163             if i = 0 then
                                1164               
           0 if                 1164               GOOD := false;                -- Begins with an "_"
                                1165               return;
                                1166             elsif 
           0 sequence           1166                   lastu then
                                1167               
           0 elsif              1167               GOOD := false;                -- "__" detected
                                1168               return;
                                1169             else
                                1170               
           0 else               1170               lastu := true;
                                1171             end if;
                                1172           elsif (
           0 sequence           1172                  char_to_MVL9plus(c) = error) then
                                1173             
           0 elsif              1173             GOOD := false;                  -- Illegal character
                                1174             return;
                                1175           else
                                1176             
           0 else               1176             mv(i) := char_to_MVL9(c);
                                1177             i := i + 1;
                                1178             
           0 if                 1179               VALUE := mv;
                                1180               return;
                                1181             end if;
                                1182             
           0 implicit_else      1178             if i > mv'high then             -- reading done
                                1179               
           0 reconvergence      1182             lastu := false;
                                1183           end if;
                                1184           
           0 reconvergence      1184           read(L, c, readOk);
                                1185         end loop;
                                1186       else
                                1187         
           0 else               1187         GOOD := true;                   -- read into a null array
                                1188       end if;
                                1189     end procedure READ
           0 sequence           1220       VALUE := (VALUE'range => 'U'); -- initialize to a "U"
                                1221       skip_whitespace (L);
                                1222       
           0 if                 1223         read (L, c, readOk);
                                1224         i := 0;
                                1225         while 
           0 sequence           1225               i < VALUE'length loop
                                1226           
           0 loop_body          1226           if readOk = false then              -- Bail out if there was a bad read
                                1227             
           0 if                 1227             report "STD_LOGIC_1164.READ(STD_ULOGIC_VECTOR) "
                                1228               & "End of string encountered"
                                1229               severity error;
                                1230             return;
                                1231           elsif 
           0 sequence           1231                 c = '_' then
                                1232             
           0 elsif              1232             if i = 0 then
                                1233               
           0 if                 1233               report "STD_LOGIC_1164.READ(STD_ULOGIC_VECTOR) "
                                1234                 & "String begins with an ""_""" severity error;
                                1235               return;
                                1236             elsif 
           0 sequence           1236                   lastu then
                                1237               
           0 elsif              1237               report "STD_LOGIC_1164.READ(STD_ULOGIC_VECTOR) "
                                1238                 & "Two underscores detected in input string ""__"""
                                1239                 severity error;
                                1240               return;
                                1241             else
                                1242               
           0 else               1242               lastu := true;
                                1243             end if;
                                1244           elsif 
           0 sequence           1244                 char_to_MVL9plus(c) = error then
                                1245             
           0 elsif              1245             report
                                1246               "STD_LOGIC_1164.READ(STD_ULOGIC_VECTOR) Error: Character '" &
                                1247               c & "' read, expected STD_ULOGIC literal."
                                1248               severity error;
                                1249             return;
                                1250           else
                                1251             
           0 else               1251             mv(i) := char_to_MVL9(c);
                                1252             i := i + 1;
                                1253             
           0 if                 1254               VALUE := mv;
                                1255               return;
                                1256             end if;
                                1257             
           0 implicit_else      1253             if i > mv'high then
                                1254               
           0 reconvergence      1257             lastu := false;
                                1258           end if;
                                1259           
           0 reconvergence      1259           read(L, c, readOk);
                                1260         end loop;
                                1261       end if;
                                1262     end procedure READ
           0 implicit_else      1222       if VALUE'length > 0 then            -- non Null input string
                                1223         
           0 sequence           1267       write(L, MVL9_to_char(VALUE), JUSTIFIED, FIELD);
                                1268     end procedure WRITE
           0 sequence           1275       for i in 1 to VALUE'length loop
                                1276         
           0 loop_body          1276         s(i) := MVL9_to_char(m(i));
                                1277       end loop;
                                1278       
           0 reconvergence      1278       write(L, s, JUSTIFIED, FIELD);
                                1279     end procedure WRITE
           0 sequence           1317       VALUE := (VALUE'range => 'U'); -- initialize to a "U"
                                1318       skip_whitespace (L);
                                1319       if VALUE'length > 0 then
                                1320         
           0 if                 1320         read (L, c, ok);
                                1321         i := 0;
                                1322         while 
           0 sequence           1322               i < ne loop
                                1323           -- Bail out if there was a bad read
                                1324           
           0 loop_body          1324           if not ok then
                                1325             
           0 if                 1325             GOOD := false;
                                1326             return;
                                1327           elsif 
           0 sequence           1327                 c = '_' then
                                1328             
           0 elsif              1328             if i = 0 then
                                1329               
           0 if                 1329               GOOD := false;                -- Begins with an "_"
                                1330               return;
                                1331             elsif 
           0 sequence           1331                   lastu then
                                1332               
           0 elsif              1332               GOOD := false;                -- "__" detected
                                1333               return;
                                1334             else
                                1335               
           0 else               1335               lastu := true;
                                1336             end if;
                                1337           else
                                1338             
           0 reconvergence      1338             Char2TriBits(c, sv(3*i to 3*i+2), ok, false);
                                1339             
           0 if                 1340               GOOD := false;
                                1341               return;
                                1342             end if;
                                1343             
           0 implicit_else      1339             if not ok then
                                1340               
           0 reconvergence      1343             i := i + 1;
                                1344             lastu := false;
                                1345           end if;
                                1346           
           0 if                 1347             read(L, c, ok);
                                1348           end if;
                                1349         end loop;
                                1350         
           0 implicit_else      1346           if i < ne then
                                1347             
           0 reconvergence      1350         if or (sv (0 to pad-1)) = '1' then
                                1351           
           0 if                 1351           GOOD := false;                           -- vector was truncated.
                                1352         else
                                1353           
           0 else               1353           GOOD  := true;
                                1354           VALUE := sv (pad to sv'high);
                                1355         end if;
                                1356       else
                                1357         
           0 else               1357         GOOD := true;                  -- read into a null array
                                1358       end if;
                                1359     end procedure OREAD
           0 sequence           1370       VALUE := (VALUE'range => 'U'); -- initialize to a "U"
                                1371       skip_whitespace (L);
                                1372       
           0 if                 1373         read (L, c, ok);
                                1374         i := 0;
                                1375         while 
           0 sequence           1375               i < ne loop
                                1376           -- Bail out if there was a bad read
                                1377           
           0 loop_body          1377           if not ok then
                                1378             
           0 if                 1378             report "STD_LOGIC_1164.OREAD "
                                1379               & "End of string encountered"
                                1380               severity error;
                                1381             return;
                                1382           elsif 
           0 sequence           1382                 c = '_' then
                                1383             
           0 elsif              1383             if i = 0 then
                                1384               
           0 if                 1384               report "STD_LOGIC_1164.OREAD "
                                1385                 & "String begins with an ""_""" severity error;
                                1386               return;
                                1387             elsif 
           0 sequence           1387                   lastu then
                                1388               
           0 elsif              1388               report "STD_LOGIC_1164.OREAD "
                                1389                 & "Two underscores detected in input string ""__"""
                                1390                 severity error;
                                1391               return;
                                1392             else
                                1393               
           0 else               1393               lastu := true;
                                1394             end if;
                                1395           else
                                1396             
           0 else               1396             Char2TriBits(c, sv(3*i to 3*i+2), ok, true);
                                1397             
           0 if                 1398               return;
                                1399             end if;
                                1400             
           0 implicit_else      1397             if not ok then
                                1398               
           0 reconvergence      1400             i := i + 1;
                                1401             lastu := false;
                                1402           end if;
                                1403           
           0 if                 1404             read(L, c, ok);
                                1405           end if;
                                1406         end loop;
                                1407         
           0 implicit_else      1403           if i < ne then
                                1404             
           0 reconvergence      1407         if or (sv (0 to pad-1)) = '1' then
                                1408           
           0 if                 1408           report "STD_LOGIC_1164.OREAD Vector truncated"
                                1409             severity error;
                                1410         else
                                1411           
           0 else               1411           VALUE := sv (pad to sv'high);
                                1412         end if;
                                1413       end if;
                                1414     end procedure OREAD
           0 implicit_else      1372       if VALUE'length > 0 then
                                1373         
           0 sequence           1460       VALUE := (VALUE'range => 'U'); -- initialize to a "U"
                                1461       skip_whitespace (L);
                                1462       if VALUE'length > 0 then
                                1463         
           0 if                 1463         read (L, c, ok);
                                1464         i := 0;
                                1465         while 
           0 sequence           1465               i < ne loop
                                1466           -- Bail out if there was a bad read
                                1467           
           0 loop_body          1467           if not ok then
                                1468             
           0 if                 1468             GOOD := false;
                                1469             return;
                                1470           elsif 
           0 sequence           1470                 c = '_' then
                                1471             
           0 elsif              1471             if i = 0 then
                                1472               
           0 if                 1472               GOOD := false;                -- Begins with an "_"
                                1473               return;
                                1474             elsif 
           0 sequence           1474                   lastu then
                                1475               
           0 elsif              1475               GOOD := false;                -- "__" detected
                                1476               return;
                                1477             else
                                1478               
           0 else               1478               lastu := true;
                                1479             end if;
                                1480           else
                                1481             
           0 reconvergence      1481             Char2QuadBits(c, sv(4*i to 4*i+3), ok, false);
                                1482             
           0 if                 1483               GOOD := false;
                                1484               return;
                                1485             end if;
                                1486             
           0 implicit_else      1482             if not ok then
                                1483               
           0 reconvergence      1486             i := i + 1;
                                1487             lastu := false;
                                1488           end if;
                                1489           
           0 if                 1490             read(L, c, ok);
                                1491           end if;
                                1492         end loop;
                                1493         
           0 implicit_else      1489           if i < ne then
                                1490             
           0 reconvergence      1493         if or (sv (0 to pad-1)) = '1' then
                                1494           
           0 if                 1494           GOOD := false;                           -- vector was truncated.
                                1495         else
                                1496           
           0 else               1496           GOOD  := true;
                                1497           VALUE := sv (pad to sv'high);
                                1498         end if;
                                1499       else
                                1500         
           0 else               1500         GOOD := true;                     -- Null input string, skips whitespace
                                1501       end if;
                                1502     end procedure HREAD
           0 sequence           1513       VALUE := (VALUE'range => 'U'); -- initialize to a "U"
                                1514       skip_whitespace (L);
                                1515       
           0 if                 1516         read (L, c, ok);
                                1517         i := 0;
                                1518         while 
           0 sequence           1518               i < ne loop
                                1519           -- Bail out if there was a bad read
                                1520           
           0 if                 1521             report "STD_LOGIC_1164.HREAD "
                                1522               & "End of string encountered"
                                1523               severity error;
                                1524             return;
                                1525           end if;
                                1526           
           0 implicit_else      1520           if not ok then
                                1521             
           0 reconvergence      1526           if c = '_' then
                                1527             
           0 if                 1527             if i = 0 then
                                1528               
           0 if                 1528               report "STD_LOGIC_1164.HREAD "
                                1529                 & "String begins with an ""_""" severity error;
                                1530               return;
                                1531             elsif 
           0 sequence           1531                   lastu then
                                1532               
           0 elsif              1532               report "STD_LOGIC_1164.HREAD "
                                1533                 & "Two underscores detected in input string ""__"""
                                1534                 severity error;
                                1535               return;
                                1536             else
                                1537               
           0 else               1537               lastu := true;
                                1538             end if;
                                1539           else
                                1540             
           0 else               1540             Char2QuadBits(c, sv(4*i to 4*i+3), ok, true);
                                1541             
           0 if                 1542               return;
                                1543             end if;
                                1544             
           0 implicit_else      1541             if not ok then
                                1542               
           0 reconvergence      1544             i := i + 1;
                                1545             lastu := false;
                                1546           end if;
                                1547           
           0 if                 1548             read(L, c, ok);
                                1549           end if;
                                1550         end loop;
                                1551         
           0 implicit_else      1547           if i < ne then
                                1548             
           0 reconvergence      1551         if or (sv (0 to pad-1)) = '1' then
                                1552           
           0 if                 1552           report "STD_LOGIC_1164.HREAD Vector truncated"
                                1553             severity error;
                                1554         else
                                1555           
           0 else               1555           VALUE := sv (pad to sv'high);
                                1556         end if;
                                1557       end if;
                                1558     end procedure HREAD
           0 implicit_else      1515       if VALUE'length > 0 then           -- non Null input string
                                1516         
           0 sequence           1563       write (L, TO_OSTRING(VALUE), JUSTIFIED, FIELD);
                                1564     end procedure OWRITE
           0 sequence           1569       write (L, TO_HSTRING (VALUE), JUSTIFIED, FIELD);
                                1570     end procedure HWRITE
           0 sequence           1113       while 
           0 sequence           1113             L /= null and L.all'length /= 0 loop
                                1114         
           0 loop_body          1114         left := L.all'left;
                                1115         c := L.all(left);
                                1116         if (c = ' ' or c = NBSP or c = HT) then
                                1117           
           0 if                 1117           read (L, c);
                                1118         else
                                1119           
           0 else               1119           exit;
                                1120         end if;
                                1121       end loop;
                                1122     end procedure skip_whitespace
           0 sequence           1286       case C is
                                1287         when '0' => 
           0 case_item          1287                     RESULT := o"0"; GOOD := true;
                                1288         when '1' => 
           0 case_item          1288                     RESULT := o"1"; GOOD := true;
                                1289         when '2' => 
           0 case_item          1289                     RESULT := o"2"; GOOD := true;
                                1290         when '3' => 
           0 case_item          1290                     RESULT := o"3"; GOOD := true;
                                1291         when '4' => 
           0 case_item          1291                     RESULT := o"4"; GOOD := true;
                                1292         when '5' => 
           0 case_item          1292                     RESULT := o"5"; GOOD := true;
                                1293         when '6' => 
           0 case_item          1293                     RESULT := o"6"; GOOD := true;
                                1294         when '7' => 
           0 case_item          1294                     RESULT := o"7"; GOOD := true;
                                1295         when 'Z' => 
           0 case_item          1295                     RESULT := "ZZZ"; GOOD := true;
                                1296         when 'X' => 
           0 case_item          1296                     RESULT := "XXX"; GOOD := true;
                                1297         when others =>
                                1298           
           0 case_item          1298           assert not ISSUE_ERROR
                                1299             report
                                1300             "STD_LOGIC_1164.OREAD Error: Read a '" & C &
                                1301             "', expected an Octal character (0-7)."
                                1302             severity error;
                                1303           GOOD := false;
                                1304       end case;
                                1305     end procedure Char2TriBits
           0 sequence           1421       case C is
                                1422         when '0'       => 
           0 case_item          1422                           RESULT := x"0"; GOOD := true;
                                1423         when '1'       => 
           0 case_item          1423                           RESULT := x"1"; GOOD := true;
                                1424         when '2'       => 
           0 case_item          1424                           RESULT := x"2"; GOOD := true;
                                1425         when '3'       => 
           0 case_item          1425                           RESULT := x"3"; GOOD := true;
                                1426         when '4'       => 
           0 case_item          1426                           RESULT := x"4"; GOOD := true;
                                1427         when '5'       => 
           0 case_item          1427                           RESULT := x"5"; GOOD := true;
                                1428         when '6'       => 
           0 case_item          1428                           RESULT := x"6"; GOOD := true;
                                1429         when '7'       => 
           0 case_item          1429                           RESULT := x"7"; GOOD := true;
                                1430         when '8'       => 
           0 case_item          1430                           RESULT := x"8"; GOOD := true;
                                1431         when '9'       => 
           0 case_item          1431                           RESULT := x"9"; GOOD := true;
                                1432         when 'A' | 'a' => 
           0 case_item          1432                           RESULT := x"A"; GOOD := true;
                                1433         when 'B' | 'b' => 
           0 case_item          1433                           RESULT := x"B"; GOOD := true;
                                1434         when 'C' | 'c' => 
           0 case_item          1434                           RESULT := x"C"; GOOD := true;
                                1435         when 'D' | 'd' => 
           0 case_item          1435                           RESULT := x"D"; GOOD := true;
                                1436         when 'E' | 'e' => 
           0 case_item          1436                           RESULT := x"E"; GOOD := true;
                                1437         when 'F' | 'f' => 
           0 case_item          1437                           RESULT := x"F"; GOOD := true;
                                1438         when 'Z'       => 
           0 case_item          1438                           RESULT := "ZZZZ"; GOOD := true;
                                1439         when 'X'       => 
           0 case_item          1439                           RESULT := "XXXX"; GOOD := true;
                                1440         when others =>
                                1441           
           0 case_item          1441           assert not ISSUE_ERROR
                                1442             report
                                1443             "STD_LOGIC_1164.HREAD Error: Read a '" & C &
                                1444             "', expected a Hex character (0-F)."
                                1445             severity error;
                                1446           GOOD := false;
                                1447       end case;
                                1448     end procedure Char2QuadBits

Line coverage for $root.$pkgs.not_ieee.numeric_std:

Coverage for source: not_ieee/2008/numeric_std-body.vhdl

          50 if                  338                              return NAS;
                                 339       end if;
                                 340       
          25 implicit_else       338       if ARG'length < 1 then 
          25 reconvergence       340       RESULT := TO_01(XARG, 'X');
                                 341       
          25 if                  341                                           return RESULT;
                                 342       end if;
                                 343       
           0 implicit_else       341       if (RESULT(RESULT'left) = 'X') then 
           0 if                  344         RESULT := -RESULT;
                                 345       end if;
                                 346       
           0 implicit_else       343       if RESULT(RESULT'left) = '1' then
                                 344         
           0 reconvergence       346       return RESULT;
                                 347     end function "abs"
           0 if                  355                              return NAS;
                                 356       end if;
                                 357       
           0 implicit_else       355       if ARG'length < 1 then 
           0 reconvergence       357       XARG01 := TO_01(ARG, 'X');
                                 358       
           0 if                  358                                           return XARG01;
                                 359       end if;
                                 360       
           0 implicit_else       358       if (XARG01(XARG01'left) = 'X') then 
           0 reconvergence       360       for I in 0 to RESULT'left loop
                                 361         
           0 loop_body           361         RESULT(I) := not(XARG01(I)) xor CBIT;
                                 362         CBIT      := CBIT and not(XARG01(I));
                                 363       end loop;
                                 364       
           0 reconvergence       364       return RESULT;
                                 365     end function "-"
           0 if                  375                                                  return NAU;
                                 376       end if;
                                 377       
           0 implicit_else       375       if ((L'length < 1) or (R'length < 1)) then 
           0 reconvergence       377       L01 := TO_01(RESIZE(L, SIZE), 'X');
                                 378       
           0 if                  378                                     return L01;
                                 379       end if;
                                 380       
           0 implicit_else       378       if (L01(L01'left) = 'X') then 
           0 reconvergence       380       R01 := TO_01(RESIZE(R, SIZE), 'X');
                                 381       
           0 if                  381                                     return R01;
                                 382       end if;
                                 383       
           0 implicit_else       381       if (R01(R01'left) = 'X') then 
           0 reconvergence       383       return ADD_UNSIGNED(L01, R01, '0');
                                 384     end function "+"
           0 sequence            392       XR(0) := R;
                                 393       return (L + XR);
                                 394     end function "+"
           0 sequence            402       XL(0) := L;
                                 403       return (XL + R);
                                 404     end function "+"
           0 if                  412                                                  return NAS;
                                 413       end if;
                                 414       
           0 implicit_else       412       if ((L'length < 1) or (R'length < 1)) then 
           0 reconvergence       414       L01 := TO_01(RESIZE(L, SIZE), 'X');
                                 415       
           0 if                  415                                     return L01;
                                 416       end if;
                                 417       
           0 implicit_else       415       if (L01(L01'left) = 'X') then 
           0 reconvergence       417       R01 := TO_01(RESIZE(R, SIZE), 'X');
                                 418       
           0 if                  418                                     return R01;
                                 419       end if;
                                 420       
           0 implicit_else       418       if (R01(R01'left) = 'X') then 
           0 reconvergence       420       return ADD_SIGNED(L01, R01, '0');
                                 421     end function "+"
           0 sequence            429       XR(0) := R;
                                 430       return (L + XR);
                                 431     end function "+"
           0 sequence            439       XL(0) := L;
                                 440       return (XL + R);
                                 441     end function "+"
           0 sequence            447       return L + TO_UNSIGNED(R, L'length);
                                 448     end function "+"
           0 sequence            454       return TO_UNSIGNED(L, R'length) + R;
                                 455     end function "+"
           0 sequence            468       return TO_SIGNED(L, R'length) + R;
                                 469     end function "+"
           0 sequence            461       return L + TO_SIGNED(R, L'length);
                                 462     end function "+"
           0 if                  479                                                  return NAU;
                                 480       end if;
                                 481       
           0 implicit_else       479       if ((L'length < 1) or (R'length < 1)) then 
           0 reconvergence       481       L01 := TO_01(RESIZE(L, SIZE), 'X');
                                 482       
           0 if                  482                                     return L01;
                                 483       end if;
                                 484       
           0 implicit_else       482       if (L01(L01'left) = 'X') then 
           0 reconvergence       484       R01 := TO_01(RESIZE(R, SIZE), 'X');
                                 485       
           0 if                  485                                     return R01;
                                 486       end if;
                                 487       
           0 implicit_else       485       if (R01(R01'left) = 'X') then 
           0 reconvergence       487       return ADD_UNSIGNED(L01, not(R01), '1');
                                 488     end function "-"
           0 sequence            496       XR(0) := R;
                                 497       return (L - XR);
                                 498     end function "-"
           0 sequence            506       XL(0) := L;
                                 507       return (XL - R);
                                 508     end function "-"
           0 if                  516                                                  return NAS;
                                 517       end if;
                                 518       
           0 implicit_else       516       if ((L'length < 1) or (R'length < 1)) then 
           0 reconvergence       518       L01 := TO_01(RESIZE(L, SIZE), 'X');
                                 519       
           0 if                  519                                     return L01;
                                 520       end if;
                                 521       
           0 implicit_else       519       if (L01(L01'left) = 'X') then 
           0 reconvergence       521       R01 := TO_01(RESIZE(R, SIZE), 'X');
                                 522       
           0 if                  522                                     return R01;
                                 523       end if;
                                 524       
           0 implicit_else       522       if (R01(R01'left) = 'X') then 
           0 reconvergence       524       return ADD_SIGNED(L01, not(R01), '1');
                                 525     end function "-"
           0 sequence            533       XR(0) := R;
                                 534       return (L - XR);
                                 535     end function "-"
           0 sequence            543       XL(0) := L;
                                 544       return (XL - R);
                                 545     end function "-"
           0 sequence            551       return L - TO_UNSIGNED(R, L'length);
                                 552     end function "-"
           0 sequence            558       return TO_UNSIGNED(L, R'length) - R;
                                 559     end function "-"
           0 sequence            564       return L - TO_SIGNED(R, L'length);
                                 565     end function "-"
           0 sequence            570       return TO_SIGNED(L, R'length) - R;
                                 571     end function "-"
           0 if                  587                                                  return NAU;
                                 588       end if;
                                 589       
           0 implicit_else       587       if ((L'length < 1) or (R'length < 1)) then 
           0 reconvergence       589       XL := TO_01(XXL, 'X');
                                 590       XR := TO_01(XXR, 'X');
                                 591       
           0 if                  592         RESULT := (others => 'X');
                                 593         return RESULT;
                                 594       end if;
                                 595       
           0 implicit_else       591       if ((XL(XL'left) = 'X') or (XR(XR'left) = 'X')) then
                                 592         
           0 reconvergence       595       ADVAL := RESIZE(XR, RESULT'length);
                                 596       for I in 0 to L_LEFT loop
                                 597         
           0 reconvergence       599         ADVAL                      := SHIFT_LEFT(ADVAL, 1);
                                 600       end loop;
                                 601       
           0 reconvergence       601       return RESULT;
                                 602     end function "*"
           0 if                  597                             RESULT := RESULT + ADVAL;
                                 598         end if;
                                 599         
           0 else                597         if XL(I) = '1' then 
           0 sequence            614       if ((L_LEFT < 0) or (R_LEFT < 0)) then 
           0 if                  614                                              return NAS;
                                 615       end if;
                                 616       
           0 reconvergence       616       XL := TO_01(L, 'X');
                                 617       XR := TO_01(R, 'X');
                                 618       
           0 if                  619         RESULT := (others => 'X');
                                 620         return RESULT;
                                 621       end if;
                                 622       
           0 implicit_else       618       if ((XL(L_LEFT) = 'X') or (XR(R_LEFT) = 'X')) then
                                 619         
           0 reconvergence       622       ADVAL := RESIZE(XR, RESULT'length);
                                 623       for I in 0 to L_LEFT-1 loop
                                 624         
           0 reconvergence       626         ADVAL                      := SHIFT_LEFT(ADVAL, 1);
                                 627       end loop;
                                 628       
           0 if                  624                             RESULT := RESULT + ADVAL;
                                 625         end if;
                                 626         
           0 else                624         if XL(I) = '1' then 
           0 if                  629         RESULT := RESULT - ADVAL;
                                 630       end if;
                                 631       
           0 implicit_else       628       if XL(L_LEFT) = '1' then
                                 629         
           0 reconvergence       631       return RESULT;
                                 632     end function "*"
           0 sequence            638       return L * TO_UNSIGNED(R, L'length);
                                 639     end function "*"
           0 sequence            645       return TO_UNSIGNED(L, R'length) * R;
                                 646     end function "*"
           0 sequence            652       return L * TO_SIGNED(R, L'length);
                                 653     end function "*"
           0 sequence            658       return TO_SIGNED(L, R'length) * R;
                                 659     end function "*"
           0 if                  674                                                  return NAU;
                                 675       end if;
                                 676       
           0 implicit_else       674       if ((L'length < 1) or (R'length < 1)) then 
           0 reconvergence       676       XL := TO_01(XXL, 'X');
                                 677       XR := TO_01(XXR, 'X');
                                 678       
           0 if                  679         FQUOT := (others => 'X');
                                 680         return FQUOT;
                                 681       end if;
                                 682       
           0 implicit_else       678       if ((XL(XL'left) = 'X') or (XR(XR'left) = 'X')) then
                                 679         
           0 reconvergence       682       DIVMOD(XL, XR, FQUOT, FREMAIN);
                                 683       return FQUOT;
                                 684     end function "/"
           0 if                  700                                                  return NAS;
                                 701       end if;
                                 702       
           0 implicit_else       700       if ((L'length < 1) or (R'length < 1)) then 
           0 reconvergence       702       XL := TO_01(XXL, 'X');
                                 703       XR := TO_01(XXR, 'X');
                                 704       
           0 if                  705         FQUOT := (others => 'X');
                                 706         return UNRESOLVED_SIGNED(FQUOT);
                                 707       end if;
                                 708       
           0 implicit_else       704       if ((XL(XL'left) = 'X') or (XR(XR'left) = 'X')) then
                                 705         
           0 reconvergence       708       if XL(XL'left) = '1' then
                                 709         
           0 if                  709         XNUM := UNRESOLVED_UNSIGNED(-XL);
                                 710         QNEG := true;
                                 711       else
                                 712         
           0 else                712         XNUM := UNRESOLVED_UNSIGNED(XL);
                                 713       end if;
                                 714       
           0 reconvergence       714       if XR(XR'left) = '1' then
                                 715         
           0 if                  715         XDENOM := UNRESOLVED_UNSIGNED(-XR);
                                 716         QNEG   := not QNEG;
                                 717       else
                                 718         
           0 else                718         XDENOM := UNRESOLVED_UNSIGNED(XR);
                                 719       end if;
                                 720       
           0 reconvergence       720       DIVMOD(XNUM, XDENOM, FQUOT, FREMAIN);
                                 721       
           0 if                  721                    FQUOT := "0"-FQUOT;
                                 722       end if;
                                 723       
           0 implicit_else       721       if QNEG then 
           0 reconvergence       723       return UNRESOLVED_SIGNED(FQUOT);
                                 724     end function "/"
           0 if                  733                              return NAU;
                                 734       end if;
                                 735       
           0 implicit_else       733       if (L'length < 1) then 
           0 if                  736         QUOT := (others => '0');
                                 737         return RESIZE(QUOT, L'length);
                                 738       end if;
                                 739       
           0 implicit_else       735       if (R_LENGTH > L'length) then
                                 736         
           0 reconvergence       739       XR   := TO_UNSIGNED(R, R_LENGTH);
                                 740       QUOT := RESIZE((L / XR), QUOT'length);
                                 741       return RESIZE(QUOT, L'length);
                                 742     end function "/"
           0 if                  751                              return NAU;
                                 752       end if;
                                 753       
           0 implicit_else       751       if (R'length < 1) then 
           0 reconvergence       753       XL   := TO_UNSIGNED(L, L_LENGTH);
                                 754       QUOT := RESIZE((XL / R), QUOT'length);
                                 755       
           0 if                  759         assert NO_WARNING report "NUMERIC_STD.""/"": Quotient Truncated"
                                 760           severity warning;
                                 761       end if;
                                 762       
           0 implicit_else       755       if L_LENGTH > R'length and QUOT(0) /= 'X'
                                 756         and QUOT(L_LENGTH-1 downto R'length)
                                 757         /= (L_LENGTH-1 downto R'length => '0')
                                 758       then
                                 759         
           0 reconvergence       762       return RESIZE(QUOT, R'length);
                                 763     end function "/"
           0 if                  770                              return NAS;
                                 771       end if;
                                 772       
           0 implicit_else       770       if (L'length < 1) then 
           0 if                  773         QUOT := (others => '0');
                                 774         return RESIZE(QUOT, L'length);
                                 775       end if;
                                 776       
           0 implicit_else       772       if (R_LENGTH > L'length) then
                                 773         
           0 reconvergence       776       XR   := TO_SIGNED(R, R_LENGTH);
                                 777       QUOT := RESIZE((L / XR), QUOT'length);
                                 778       return RESIZE(QUOT, L'length);
                                 779     end function "/"
           0 if                  786                              return NAS;
                                 787       end if;
                                 788       
           0 implicit_else       786       if (R'length < 1) then 
           0 reconvergence       788       XL   := TO_SIGNED(L, L_LENGTH);
                                 789       QUOT := RESIZE((XL / R), QUOT'length);
                                 790       
           0 if                  794         assert NO_WARNING report "NUMERIC_STD.""/"": Quotient Truncated"
                                 795           severity warning;
                                 796       end if;
                                 797       
           0 implicit_else       790       if L_LENGTH > R'length and QUOT(0) /= 'X'
                                 791         and QUOT(L_LENGTH-1 downto R'length)
                                 792         /= (L_LENGTH-1 downto R'length => QUOT(R'length-1))
                                 793       then
                                 794         
           0 reconvergence       797       return RESIZE(QUOT, R'length);
                                 798     end function "/"
           0 if                  813                                                  return NAU;
                                 814       end if;
                                 815       
           0 implicit_else       813       if ((L'length < 1) or (R'length < 1)) then 
           0 reconvergence       815       XL := TO_01(XXL, 'X');
                                 816       XR := TO_01(XXR, 'X');
                                 817       
           0 if                  818         FREMAIN := (others => 'X');
                                 819         return FREMAIN;
                                 820       end if;
                                 821       
           0 implicit_else       817       if ((XL(XL'left) = 'X') or (XR(XR'left) = 'X')) then
                                 818         
           0 reconvergence       821       DIVMOD(XL, XR, FQUOT, FREMAIN);
                                 822       return FREMAIN;
                                 823     end function "rem"
           0 if                  837                                                  return NAS;
                                 838       end if;
                                 839       
           0 implicit_else       837       if ((L'length < 1) or (R'length < 1)) then 
           0 reconvergence       839       XNUM   := UNRESOLVED_UNSIGNED(TO_01(XXL, 'X'));
                                 840       XDENOM := UNRESOLVED_UNSIGNED(TO_01(XXR, 'X'));
                                 841       
           0 if                  842         FREMAIN := (others => 'X');
                                 843         return UNRESOLVED_SIGNED(FREMAIN);
                                 844       end if;
                                 845       
           0 implicit_else       841       if ((XNUM(XNUM'left) = 'X') or (XDENOM(XDENOM'left) = 'X')) then
                                 842         
           0 reconvergence       845       if XNUM(XNUM'left) = '1' then
                                 846         
           0 if                  846         XNUM := UNRESOLVED_UNSIGNED(-UNRESOLVED_SIGNED(XNUM));
                                 847         RNEG := true;
                                 848       else
                                 849         
           0 else                849         XNUM := UNRESOLVED_UNSIGNED(XNUM);
                                 850       end if;
                                 851       
           0 reconvergence       851       if XDENOM(XDENOM'left) = '1' then
                                 852         
           0 if                  852         XDENOM := UNRESOLVED_UNSIGNED(-UNRESOLVED_SIGNED(XDENOM));
                                 853       else
                                 854         
           0 else                854         XDENOM := UNRESOLVED_UNSIGNED(XDENOM);
                                 855       end if;
                                 856       
           0 reconvergence       856       DIVMOD(XNUM, XDENOM, FQUOT, FREMAIN);
                                 857       
           0 if                  858         FREMAIN := "0"-FREMAIN;
                                 859       end if;
                                 860       
           0 implicit_else       857       if RNEG then
                                 858         
           0 reconvergence       860       return UNRESOLVED_SIGNED(FREMAIN);
                                 861     end function "rem"
           0 if                  870                              return NAU;
                                 871       end if;
                                 872       
           0 implicit_else       870       if (L'length < 1) then 
           0 reconvergence       872       XR   := TO_UNSIGNED(R, R_LENGTH);
                                 873       XREM := L rem XR;
                                 874       
           0 if                  878         assert NO_WARNING report "NUMERIC_STD.""rem"": Remainder Truncated"
                                 879           severity warning;
                                 880       end if;
                                 881       
           0 implicit_else       874       if R_LENGTH > L'length and XREM(0) /= 'X'
                                 875         and XREM(R_LENGTH-1 downto L'length)
                                 876         /= (R_LENGTH-1 downto L'length => '0')
                                 877       then
                                 878         
           0 reconvergence       881       return RESIZE(XREM, L'length);
                                 882     end function "rem"
           0 sequence            891       XL   := TO_UNSIGNED(L, L_LENGTH);
                                 892       XREM := XL rem R;
                                 893       
           0 if                  897         assert NO_WARNING report "NUMERIC_STD.""rem"": Remainder Truncated"
                                 898           severity warning;
                                 899       end if;
                                 900       
           0 implicit_else       893       if L_LENGTH > R'length and XREM(0) /= 'X'
                                 894         and XREM(L_LENGTH-1 downto R'length)
                                 895         /= (L_LENGTH-1 downto R'length => '0')
                                 896       then
                                 897         
           0 reconvergence       900       return RESIZE(XREM, R'length);
                                 901     end function "rem"
           0 if                  910                              return NAS;
                                 911       end if;
                                 912       
           0 implicit_else       910       if (L'length < 1) then 
           0 reconvergence       912       XR   := TO_SIGNED(R, R_LENGTH);
                                 913       XREM := RESIZE((L rem XR), XREM'length);
                                 914       
           0 if                  918         assert NO_WARNING report "NUMERIC_STD.""rem"": Remainder Truncated"
                                 919           severity warning;
                                 920       end if;
                                 921       
           0 implicit_else       914       if R_LENGTH > L'length and XREM(0) /= 'X'
                                 915         and XREM(R_LENGTH-1 downto L'length)
                                 916         /= (R_LENGTH-1 downto L'length => XREM(L'length-1))
                                 917       then
                                 918         
           0 reconvergence       921       return RESIZE(XREM, L'length);
                                 922     end function "rem"
           0 if                  931                              return NAS;
                                 932       end if;
                                 933       
           0 implicit_else       931       if (R'length < 1) then 
           0 reconvergence       933       XL   := TO_SIGNED(L, L_LENGTH);
                                 934       XREM := RESIZE((XL rem R), XREM'length);
                                 935       
           0 if                  939         assert NO_WARNING report "NUMERIC_STD.""rem"": Remainder Truncated"
                                 940           severity warning;
                                 941       end if;
                                 942       
           0 implicit_else       935       if L_LENGTH > R'length and XREM(0) /= 'X'
                                 936         and XREM(L_LENGTH-1 downto R'length)
                                 937         /= (L_LENGTH-1 downto R'length => XREM(R'length-1))
                                 938       then
                                 939         
           0 reconvergence       942       return RESIZE(XREM, R'length);
                                 943     end function "rem"
           0 if                  958                                                  return NAU;
                                 959       end if;
                                 960       
           0 implicit_else       958       if ((L'length < 1) or (R'length < 1)) then 
           0 reconvergence       960       XL := TO_01(XXL, 'X');
                                 961       XR := TO_01(XXR, 'X');
                                 962       
           0 if                  963         FREMAIN := (others => 'X');
                                 964         return FREMAIN;
                                 965       end if;
                                 966       
           0 implicit_else       962       if ((XL(XL'left) = 'X') or (XR(XR'left) = 'X')) then
                                 963         
           0 reconvergence       966       DIVMOD(XL, XR, FQUOT, FREMAIN);
                                 967       return FREMAIN;
                                 968     end function "mod"
           0 sequence            984       if ((L'length < 1) or (R'length < 1)) then 
           0 if                  984                                                  return NAS;
                                 985       end if;
                                 986       
           0 reconvergence       986       XL := TO_01(XXL, 'X');
                                 987       XR := TO_01(XXR, 'X');
                                 988       
           0 if                  989         FREMAIN := (others => 'X');
                                 990         return UNRESOLVED_SIGNED(FREMAIN);
                                 991       end if;
                                 992       
           0 implicit_else       988       if ((XL(XL'left) = 'X') or (XR(XR'left) = 'X')) then
                                 989         
           0 reconvergence       992       if XL(XL'left) = '1' then
                                 993         
           0 if                  993         XNUM := UNRESOLVED_UNSIGNED(-XL);
                                 994       else
                                 995         
           0 else                995         XNUM := UNRESOLVED_UNSIGNED(XL);
                                 996       end if;
                                 997       
           0 reconvergence       997       if XR(XR'left) = '1' then
                                 998         
           0 if                  998         XDENOM := UNRESOLVED_UNSIGNED(-XR);
                                 999         RNEG   := true;
                                1000       else
                                1001         
           0 else               1001         XDENOM := UNRESOLVED_UNSIGNED(XR);
                                1002       end if;
                                1003       
           0 reconvergence      1003       DIVMOD(XNUM, XDENOM, FQUOT, FREMAIN);
                                1004       
           0 if                 1005         FREMAIN := "0"-FREMAIN;
                                1006       elsif 
           0 sequence           1006             RNEG and FREMAIN /= "0" then
                                1007         
           0 elsif              1007         FREMAIN := FREMAIN-XDENOM;
                                1008       elsif 
           0 sequence           1008             L(L'left) = '1' and FREMAIN /= "0" then
                                1009         
           0 elsif              1009         FREMAIN := XDENOM-FREMAIN;
                                1010       end if;
                                1011       
           0 implicit_else      1004       if RNEG and L(L'left) = '1' then
                                1005         
           0 reconvergence      1011       return UNRESOLVED_SIGNED(FREMAIN);
                                1012     end function "mod"
           0 if                 1021                              return NAU;
                                1022       end if;
                                1023       
           0 implicit_else      1021       if (L'length < 1) then 
           0 reconvergence      1023       XR   := TO_UNSIGNED(R, R_LENGTH);
                                1024       XREM := RESIZE((L mod XR), XREM'length);
                                1025       
           0 if                 1029         assert NO_WARNING report "NUMERIC_STD.""mod"": Modulus Truncated"
                                1030           severity warning;
                                1031       end if;
                                1032       
           0 implicit_else      1025       if R_LENGTH > L'length and XREM(0) /= 'X'
                                1026         and XREM(R_LENGTH-1 downto L'length)
                                1027         /= (R_LENGTH-1 downto L'length => '0')
                                1028       then
                                1029         
           0 reconvergence      1032       return RESIZE(XREM, L'length);
                                1033     end function "mod"
           0 if                 1042                              return NAU;
                                1043       end if;
                                1044       
           0 implicit_else      1042       if (R'length < 1) then 
           0 reconvergence      1044       XL   := TO_UNSIGNED(L, L_LENGTH);
                                1045       XREM := RESIZE((XL mod R), XREM'length);
                                1046       
           0 if                 1050         assert NO_WARNING report "NUMERIC_STD.""mod"": Modulus Truncated"
                                1051           severity warning;
                                1052       end if;
                                1053       
           0 implicit_else      1046       if L_LENGTH > R'length and XREM(0) /= 'X'
                                1047         and XREM(L_LENGTH-1 downto R'length)
                                1048         /= (L_LENGTH-1 downto R'length => '0')
                                1049       then
                                1050         
           0 reconvergence      1053       return RESIZE(XREM, R'length);
                                1054     end function "mod"
           0 if                 1063                              return NAS;
                                1064       end if;
                                1065       
           0 implicit_else      1063       if (L'length < 1) then 
           0 reconvergence      1065       XR   := TO_SIGNED(R, R_LENGTH);
                                1066       XREM := RESIZE((L mod XR), XREM'length);
                                1067       
           0 if                 1071         assert NO_WARNING report "NUMERIC_STD.""mod"": Modulus Truncated"
                                1072           severity warning;
                                1073       end if;
                                1074       
           0 implicit_else      1067       if R_LENGTH > L'length and XREM(0) /= 'X'
                                1068         and XREM(R_LENGTH-1 downto L'length)
                                1069         /= (R_LENGTH-1 downto L'length => XREM(L'length-1))
                                1070       then
                                1071         
           0 reconvergence      1074       return RESIZE(XREM, L'length);
                                1075     end function "mod"
           0 if                 1084                              return NAS;
                                1085       end if;
                                1086       
           0 implicit_else      1084       if (R'length < 1) then 
           0 reconvergence      1086       XL   := TO_SIGNED(L, L_LENGTH);
                                1087       XREM := RESIZE((XL mod R), XREM'length);
                                1088       
           0 if                 1092         assert NO_WARNING report "NUMERIC_STD.""mod"": Modulus Truncated"
                                1093           severity warning;
                                1094       end if;
                                1095       
           0 implicit_else      1088       if L_LENGTH > R'length and XREM(0) /= 'X'
                                1089         and XREM(L_LENGTH-1 downto R'length)
                                1090         /= (L_LENGTH-1 downto R'length => XREM(R'length-1))
                                1091       then
                                1092         
           0 reconvergence      1095       return RESIZE(XREM, R'length);
                                1096     end function "mod"
           0 sequence           1103       for INDEX in ARG'range loop
                                1104         
           0 reconvergence      1108       return -1;
                                1109     end function find_leftmost
           0 if                 1105           return INDEX;
                                1106         end if;
                                1107       end loop;
                                1108       
           0 else               1104         if ARG(INDEX) ?= Y then
                                1105           
           0 sequence           1115       for INDEX in ARG'range loop
                                1116         
           0 reconvergence      1120       return -1;
                                1121     end function find_leftmost
           0 if                 1117           return INDEX;
                                1118         end if;
                                1119       end loop;
                                1120       
           0 else               1116         if ARG(INDEX) ?= Y then
                                1117           
           0 sequence           1127       for INDEX in ARG'reverse_range loop
                                1128         
           0 reconvergence      1132       return -1;
                                1133     end function find_rightmost
           0 if                 1129           return INDEX;
                                1130         end if;
                                1131       end loop;
                                1132       
           0 else               1128         if ARG(INDEX) ?= Y then
                                1129           
           0 sequence           1139       for INDEX in ARG'reverse_range loop
                                1140         
           0 reconvergence      1144       return -1;
                                1145     end function find_rightmost
           0 if                 1141           return INDEX;
                                1142         end if;
                                1143       end loop;
                                1144       
           0 else               1140         if ARG(INDEX) ?= Y then
                                1141           
           0 if                 1160         assert NO_WARNING
                                1161           report "NUMERIC_STD."">"": null argument detected, returning FALSE"
                                1162           severity warning;
                                1163         return false;
                                1164       end if;
                                1165       
           0 implicit_else      1159       if ((L'length < 1) or (R'length < 1)) then
                                1160         
           0 reconvergence      1165       L01 := TO_01(XL, 'X');
                                1166       R01 := TO_01(XR, 'X');
                                1167       
           0 if                 1168         assert NO_WARNING
                                1169           report "NUMERIC_STD."">"": metavalue detected, returning FALSE"
                                1170           severity warning;
                                1171         return false;
                                1172       end if;
                                1173       
           0 implicit_else      1167       if ((L01(L01'left) = 'X') or (R01(R01'left) = 'X')) then
                                1168         
           0 reconvergence      1173       return not UNSIGNED_LESS_OR_EQUAL(RESIZE(L01, SIZE), RESIZE(R01, SIZE));
                                1174     end function ">"
           0 if                 1187         assert NO_WARNING
                                1188           report "NUMERIC_STD."">"": null argument detected, returning FALSE"
                                1189           severity warning;
                                1190         return false;
                                1191       end if;
                                1192       
           0 implicit_else      1186       if ((L'length < 1) or (R'length < 1)) then
                                1187         
           0 reconvergence      1192       L01 := TO_01(XL, 'X');
                                1193       R01 := TO_01(XR, 'X');
                                1194       
           0 if                 1195         assert NO_WARNING
                                1196           report "NUMERIC_STD."">"": metavalue detected, returning FALSE"
                                1197           severity warning;
                                1198         return false;
                                1199       end if;
                                1200       
           0 implicit_else      1194       if ((L01(L01'left) = 'X') or (R01(R01'left) = 'X')) then
                                1195         
           0 reconvergence      1200       return not SIGNED_LESS_OR_EQUAL(RESIZE(L01, SIZE), RESIZE(R01, SIZE));
                                1201     end function ">"
           0 if                 1210         assert NO_WARNING
                                1211           report "NUMERIC_STD."">"": null argument detected, returning FALSE"
                                1212           severity warning;
                                1213         return false;
                                1214       end if;
                                1215       
           0 implicit_else      1209       if (R'length < 1) then
                                1210         
           0 reconvergence      1215       R01 := TO_01(XR, 'X');
                                1216       
           0 if                 1217         assert NO_WARNING
                                1218           report "NUMERIC_STD."">"": metavalue detected, returning FALSE"
                                1219           severity warning;
                                1220         return false;
                                1221       end if;
                                1222       
           0 implicit_else      1216       if (R01(R01'left) = 'X') then
                                1217         
           0 if                 1222                                               return true;
                                1223       end if;
                                1224       
           0 implicit_else      1222       if UNSIGNED_NUM_BITS(L) > R'length then 
           0 reconvergence      1224       return not UNSIGNED_LESS_OR_EQUAL(TO_UNSIGNED(L, R01'length), R01);
                                1225     end function ">"
           0 if                 1234         assert NO_WARNING
                                1235           report "NUMERIC_STD."">"": null argument detected, returning FALSE"
                                1236           severity warning;
                                1237         return false;
                                1238       end if;
                                1239       
           0 implicit_else      1233       if (R'length < 1) then
                                1234         
           0 reconvergence      1239       R01 := TO_01(XR, 'X');
                                1240       
           0 if                 1241         assert NO_WARNING
                                1242           report "NUMERIC_STD."">"": metavalue detected, returning FALSE"
                                1243           severity warning;
                                1244         return false;
                                1245       end if;
                                1246       
           0 implicit_else      1240       if (R01(R01'left) = 'X') then
                                1241         
           0 if                 1246                                             return L > 0;
                                1247       end if;
                                1248       
           0 implicit_else      1246       if SIGNED_NUM_BITS(L) > R'length then 
           0 reconvergence      1248       return not SIGNED_LESS_OR_EQUAL(TO_SIGNED(L, R01'length), R01);
                                1249     end function ">"
           0 if                 1258         assert NO_WARNING
                                1259           report "NUMERIC_STD."">"": null argument detected, returning FALSE"
                                1260           severity warning;
                                1261         return false;
                                1262       end if;
                                1263       
           0 implicit_else      1257       if (L'length < 1) then
                                1258         
           0 reconvergence      1263       L01 := TO_01(XL, 'X');
                                1264       
           0 if                 1265         assert NO_WARNING
                                1266           report "NUMERIC_STD."">"": metavalue detected, returning FALSE"
                                1267           severity warning;
                                1268         return false;
                                1269       end if;
                                1270       
           0 implicit_else      1264       if (L01(L01'left) = 'X') then
                                1265         
           0 if                 1270                                               return false;
                                1271       end if;
                                1272       
           0 implicit_else      1270       if UNSIGNED_NUM_BITS(R) > L'length then 
           0 reconvergence      1272       return not UNSIGNED_LESS_OR_EQUAL(L01, TO_UNSIGNED(R, L01'length));
                                1273     end function ">"
           0 if                 1282         assert NO_WARNING
                                1283           report "NUMERIC_STD."">"": null argument detected, returning FALSE"
                                1284           severity warning;
                                1285         return false;
                                1286       end if;
                                1287       
           0 implicit_else      1281       if (L'length < 1) then
                                1282         
           0 reconvergence      1287       L01 := TO_01(XL, 'X');
                                1288       
           0 if                 1289         assert NO_WARNING
                                1290           report "NUMERIC_STD."">"": metavalue detected, returning FALSE"
                                1291           severity warning;
                                1292         return false;
                                1293       end if;
                                1294       
           0 implicit_else      1288       if (L01(L01'left) = 'X') then
                                1289         
           0 if                 1294                                             return 0 > R;
                                1295       end if;
                                1296       
           0 implicit_else      1294       if SIGNED_NUM_BITS(R) > L'length then 
           0 reconvergence      1296       return not SIGNED_LESS_OR_EQUAL(L01, TO_SIGNED(R, L01'length));
                                1297     end function ">"
           0 if                 1312         assert NO_WARNING
                                1313           report "NUMERIC_STD.""<"": null argument detected, returning FALSE"
                                1314           severity warning;
                                1315         return false;
                                1316       end if;
                                1317       
           0 implicit_else      1311       if ((L'length < 1) or (R'length < 1)) then
                                1312         
           0 reconvergence      1317       L01 := TO_01(XL, 'X');
                                1318       R01 := TO_01(XR, 'X');
                                1319       
           0 if                 1320         assert NO_WARNING
                                1321           report "NUMERIC_STD.""<"": metavalue detected, returning FALSE"
                                1322           severity warning;
                                1323         return false;
                                1324       end if;
                                1325       
           0 implicit_else      1319       if ((L01(L01'left) = 'X') or (R01(R01'left) = 'X')) then
                                1320         
           0 reconvergence      1325       return UNSIGNED_LESS(RESIZE(L01, SIZE), RESIZE(R01, SIZE));
                                1326     end function "<"
           0 if                 1339         assert NO_WARNING
                                1340           report "NUMERIC_STD.""<"": null argument detected, returning FALSE"
                                1341           severity warning;
                                1342         return false;
                                1343       end if;
                                1344       
           0 implicit_else      1338       if ((L'length < 1) or (R'length < 1)) then
                                1339         
           0 reconvergence      1344       L01 := TO_01(XL, 'X');
                                1345       R01 := TO_01(XR, 'X');
                                1346       
           0 if                 1347         assert NO_WARNING
                                1348           report "NUMERIC_STD.""<"": metavalue detected, returning FALSE"
                                1349           severity warning;
                                1350         return false;
                                1351       end if;
                                1352       
           0 implicit_else      1346       if ((L01(L01'left) = 'X') or (R01(R01'left) = 'X')) then
                                1347         
           0 reconvergence      1352       return SIGNED_LESS(RESIZE(L01, SIZE), RESIZE(R01, SIZE));
                                1353     end function "<"
           0 if                 1362         assert NO_WARNING
                                1363           report "NUMERIC_STD.""<"": null argument detected, returning FALSE"
                                1364           severity warning;
                                1365         return false;
                                1366       end if;
                                1367       
           0 implicit_else      1361       if (R'length < 1) then
                                1362         
           0 reconvergence      1367       R01 := TO_01(XR, 'X');
                                1368       
           0 if                 1369         assert NO_WARNING
                                1370           report "NUMERIC_STD.""<"": metavalue detected, returning FALSE"
                                1371           severity warning;
                                1372         return false;
                                1373       end if;
                                1374       
           0 implicit_else      1368       if (R01(R01'left) = 'X') then
                                1369         
           0 if                 1374                                               return L < 0;
                                1375       end if;
                                1376       
           0 implicit_else      1374       if UNSIGNED_NUM_BITS(L) > R'length then 
           0 reconvergence      1376       return UNSIGNED_LESS(TO_UNSIGNED(L, R01'length), R01);
                                1377     end function "<"
           0 if                 1386         assert NO_WARNING
                                1387           report "NUMERIC_STD.""<"": null argument detected, returning FALSE"
                                1388           severity warning;
                                1389         return false;
                                1390       end if;
                                1391       
           0 implicit_else      1385       if (R'length < 1) then
                                1386         
           0 reconvergence      1391       R01 := TO_01(XR, 'X');
                                1392       
           0 if                 1393         assert NO_WARNING
                                1394           report "NUMERIC_STD.""<"": metavalue detected, returning FALSE"
                                1395           severity warning;
                                1396         return false;
                                1397       end if;
                                1398       
           0 implicit_else      1392       if (R01(R01'left) = 'X') then
                                1393         
           0 if                 1398                                             return L < 0;
                                1399       end if;
                                1400       
           0 implicit_else      1398       if SIGNED_NUM_BITS(L) > R'length then 
           0 reconvergence      1400       return SIGNED_LESS(TO_SIGNED(L, R01'length), R01);
                                1401     end function "<"
           0 if                 1410         assert NO_WARNING
                                1411           report "NUMERIC_STD.""<"": null argument detected, returning FALSE"
                                1412           severity warning;
                                1413         return false;
                                1414       end if;
                                1415       
           0 implicit_else      1409       if (L'length < 1) then
                                1410         
           0 reconvergence      1415       L01 := TO_01(XL, 'X');
                                1416       
           0 if                 1417         assert NO_WARNING
                                1418           report "NUMERIC_STD.""<"": metavalue detected, returning FALSE"
                                1419           severity warning;
                                1420         return false;
                                1421       end if;
                                1422       
           0 implicit_else      1416       if (L01(L01'left) = 'X') then
                                1417         
           0 if                 1422                                               return 0 < R;
                                1423       end if;
                                1424       
           0 implicit_else      1422       if UNSIGNED_NUM_BITS(R) > L'length then 
           0 reconvergence      1424       return UNSIGNED_LESS(L01, TO_UNSIGNED(R, L01'length));
                                1425     end function "<"
           0 if                 1434         assert NO_WARNING
                                1435           report "NUMERIC_STD.""<"": null argument detected, returning FALSE"
                                1436           severity warning;
                                1437         return false;
                                1438       end if;
                                1439       
           0 implicit_else      1433       if (L'length < 1) then
                                1434         
           0 reconvergence      1439       L01 := TO_01(XL, 'X');
                                1440       
           0 if                 1441         assert NO_WARNING
                                1442           report "NUMERIC_STD.""<"": metavalue detected, returning FALSE"
                                1443           severity warning;
                                1444         return false;
                                1445       end if;
                                1446       
           0 implicit_else      1440       if (L01(L01'left) = 'X') then
                                1441         
           0 if                 1446                                             return 0 < R;
                                1447       end if;
                                1448       
           0 implicit_else      1446       if SIGNED_NUM_BITS(R) > L'length then 
           0 reconvergence      1448       return SIGNED_LESS(L01, TO_SIGNED(R, L01'length));
                                1449     end function "<"
           0 if                 1464         assert NO_WARNING
                                1465           report "NUMERIC_STD.""<="": null argument detected, returning FALSE"
                                1466           severity warning;
                                1467         return false;
                                1468       end if;
                                1469       
           0 implicit_else      1463       if ((L'length < 1) or (R'length < 1)) then
                                1464         
           0 reconvergence      1469       L01 := TO_01(XL, 'X');
                                1470       R01 := TO_01(XR, 'X');
                                1471       
           0 if                 1472         assert NO_WARNING
                                1473           report "NUMERIC_STD.""<="": metavalue detected, returning FALSE"
                                1474           severity warning;
                                1475         return false;
                                1476       end if;
                                1477       
           0 implicit_else      1471       if ((L01(L01'left) = 'X') or (R01(R01'left) = 'X')) then
                                1472         
           0 reconvergence      1477       return UNSIGNED_LESS_OR_EQUAL(RESIZE(L01, SIZE), RESIZE(R01, SIZE));
                                1478     end function "<="
           0 if                 1491         assert NO_WARNING
                                1492           report "NUMERIC_STD.""<="": null argument detected, returning FALSE"
                                1493           severity warning;
                                1494         return false;
                                1495       end if;
                                1496       
           0 implicit_else      1490       if ((L'length < 1) or (R'length < 1)) then
                                1491         
           0 reconvergence      1496       L01 := TO_01(XL, 'X');
                                1497       R01 := TO_01(XR, 'X');
                                1498       
           0 if                 1499         assert NO_WARNING
                                1500           report "NUMERIC_STD.""<="": metavalue detected, returning FALSE"
                                1501           severity warning;
                                1502         return false;
                                1503       end if;
                                1504       
           0 implicit_else      1498       if ((L01(L01'left) = 'X') or (R01(R01'left) = 'X')) then
                                1499         
           0 reconvergence      1504       return SIGNED_LESS_OR_EQUAL(RESIZE(L01, SIZE), RESIZE(R01, SIZE));
                                1505     end function "<="
           0 if                 1514         assert NO_WARNING
                                1515           report "NUMERIC_STD.""<="": null argument detected, returning FALSE"
                                1516           severity warning;
                                1517         return false;
                                1518       end if;
                                1519       
           0 implicit_else      1513       if (R'length < 1) then
                                1514         
           0 reconvergence      1519       R01 := TO_01(XR, 'X');
                                1520       
           0 if                 1521         assert NO_WARNING
                                1522           report "NUMERIC_STD.""<="": metavalue detected, returning FALSE"
                                1523           severity warning;
                                1524         return false;
                                1525       end if;
                                1526       
           0 implicit_else      1520       if (R01(R01'left) = 'X') then
                                1521         
           0 if                 1526                                               return L < 0;
                                1527       end if;
                                1528       
           0 implicit_else      1526       if UNSIGNED_NUM_BITS(L) > R'length then 
           0 reconvergence      1528       return UNSIGNED_LESS_OR_EQUAL(TO_UNSIGNED(L, R01'length), R01);
                                1529     end function "<="
           0 if                 1538         assert NO_WARNING
                                1539           report "NUMERIC_STD.""<="": null argument detected, returning FALSE"
                                1540           severity warning;
                                1541         return false;
                                1542       end if;
                                1543       
           0 implicit_else      1537       if (R'length < 1) then
                                1538         
           0 reconvergence      1543       R01 := TO_01(XR, 'X');
                                1544       
           0 if                 1545         assert NO_WARNING
                                1546           report "NUMERIC_STD.""<="": metavalue detected, returning FALSE"
                                1547           severity warning;
                                1548         return false;
                                1549       end if;
                                1550       
           0 implicit_else      1544       if (R01(R01'left) = 'X') then
                                1545         
           0 if                 1550                                             return L < 0;
                                1551       end if;
                                1552       
           0 implicit_else      1550       if SIGNED_NUM_BITS(L) > R'length then 
           0 reconvergence      1552       return SIGNED_LESS_OR_EQUAL(TO_SIGNED(L, R01'length), R01);
                                1553     end function "<="
           0 if                 1562         assert NO_WARNING
                                1563           report "NUMERIC_STD.""<="": null argument detected, returning FALSE"
                                1564           severity warning;
                                1565         return false;
                                1566       end if;
                                1567       
           0 implicit_else      1561       if (L_LEFT < 0) then
                                1562         
           0 reconvergence      1567       L01 := TO_01(XL, 'X');
                                1568       
           0 if                 1569         assert NO_WARNING
                                1570           report "NUMERIC_STD.""<="": metavalue detected, returning FALSE"
                                1571           severity warning;
                                1572         return false;
                                1573       end if;
                                1574       
           0 implicit_else      1568       if (L01(L01'left) = 'X') then
                                1569         
           0 if                 1574                                               return 0 < R;
                                1575       end if;
                                1576       
           0 implicit_else      1574       if UNSIGNED_NUM_BITS(R) > L'length then 
           0 reconvergence      1576       return UNSIGNED_LESS_OR_EQUAL(L01, TO_UNSIGNED(R, L01'length));
                                1577     end function "<="
           0 if                 1586         assert NO_WARNING
                                1587           report "NUMERIC_STD.""<="": null argument detected, returning FALSE"
                                1588           severity warning;
                                1589         return false;
                                1590       end if;
                                1591       
           0 implicit_else      1585       if (L_LEFT < 0) then
                                1586         
           0 reconvergence      1591       L01 := TO_01(XL, 'X');
                                1592       
           0 if                 1593         assert NO_WARNING
                                1594           report "NUMERIC_STD.""<="": metavalue detected, returning FALSE"
                                1595           severity warning;
                                1596         return false;
                                1597       end if;
                                1598       
           0 implicit_else      1592       if (L01(L01'left) = 'X') then
                                1593         
           0 if                 1598                                             return 0 < R;
                                1599       end if;
                                1600       
           0 implicit_else      1598       if SIGNED_NUM_BITS(R) > L'length then 
           0 reconvergence      1600       return SIGNED_LESS_OR_EQUAL(L01, TO_SIGNED(R, L01'length));
                                1601     end function "<="
           0 if                 1616         assert NO_WARNING
                                1617           report "NUMERIC_STD."">="": null argument detected, returning FALSE"
                                1618           severity warning;
                                1619         return false;
                                1620       end if;
                                1621       
           0 implicit_else      1615       if ((L'length < 1) or (R'length < 1)) then
                                1616         
           0 reconvergence      1621       L01 := TO_01(XL, 'X');
                                1622       R01 := TO_01(XR, 'X');
                                1623       
           0 if                 1624         assert NO_WARNING
                                1625           report "NUMERIC_STD."">="": metavalue detected, returning FALSE"
                                1626           severity warning;
                                1627         return false;
                                1628       end if;
                                1629       
           0 implicit_else      1623       if ((L01(L01'left) = 'X') or (R01(R01'left) = 'X')) then
                                1624         
           0 reconvergence      1629       return not UNSIGNED_LESS(RESIZE(L01, SIZE), RESIZE(R01, SIZE));
                                1630     end function ">="
           0 if                 1643         assert NO_WARNING
                                1644           report "NUMERIC_STD."">="": null argument detected, returning FALSE"
                                1645           severity warning;
                                1646         return false;
                                1647       end if;
                                1648       
           0 implicit_else      1642       if ((L'length < 1) or (R'length < 1)) then
                                1643         
           0 reconvergence      1648       L01 := TO_01(XL, 'X');
                                1649       R01 := TO_01(XR, 'X');
                                1650       
           0 if                 1651         assert NO_WARNING
                                1652           report "NUMERIC_STD."">="": metavalue detected, returning FALSE"
                                1653           severity warning;
                                1654         return false;
                                1655       end if;
                                1656       
           0 implicit_else      1650       if ((L01(L01'left) = 'X') or (R01(R01'left) = 'X')) then
                                1651         
           0 reconvergence      1656       return not SIGNED_LESS(RESIZE(L01, SIZE), RESIZE(R01, SIZE));
                                1657     end function ">="
           0 if                 1666         assert NO_WARNING
                                1667           report "NUMERIC_STD."">="": null argument detected, returning FALSE"
                                1668           severity warning;
                                1669         return false;
                                1670       end if;
                                1671       
           0 implicit_else      1665       if (R'length < 1) then
                                1666         
           0 reconvergence      1671       R01 := TO_01(XR, 'X');
                                1672       
           0 if                 1673         assert NO_WARNING
                                1674           report "NUMERIC_STD."">="": metavalue detected, returning FALSE"
                                1675           severity warning;
                                1676         return false;
                                1677       end if;
                                1678       
           0 implicit_else      1672       if (R01(R01'left) = 'X') then
                                1673         
           0 if                 1678                                               return L > 0;
                                1679       end if;
                                1680       
           0 implicit_else      1678       if UNSIGNED_NUM_BITS(L) > R'length then 
           0 reconvergence      1680       return not UNSIGNED_LESS(TO_UNSIGNED(L, R01'length), R01);
                                1681     end function ">="
           0 if                 1690         assert NO_WARNING
                                1691           report "NUMERIC_STD."">="": null argument detected, returning FALSE"
                                1692           severity warning;
                                1693         return false;
                                1694       end if;
                                1695       
           0 implicit_else      1689       if (R'length < 1) then
                                1690         
           0 reconvergence      1695       R01 := TO_01(XR, 'X');
                                1696       
           0 if                 1697         assert NO_WARNING
                                1698           report "NUMERIC_STD."">="": metavalue detected, returning FALSE"
                                1699           severity warning;
                                1700         return false;
                                1701       end if;
                                1702       
           0 implicit_else      1696       if (R01(R01'left) = 'X') then
                                1697         
           0 if                 1702                                             return L > 0;
                                1703       end if;
                                1704       
           0 implicit_else      1702       if SIGNED_NUM_BITS(L) > R'length then 
           0 reconvergence      1704       return not SIGNED_LESS(TO_SIGNED(L, R01'length), R01);
                                1705     end function ">="
           0 if                 1714         assert NO_WARNING
                                1715           report "NUMERIC_STD."">="": null argument detected, returning FALSE"
                                1716           severity warning;
                                1717         return false;
                                1718       end if;
                                1719       
           0 implicit_else      1713       if (L'length < 1) then
                                1714         
           0 reconvergence      1719       L01 := TO_01(XL, 'X');
                                1720       
           0 if                 1721         assert NO_WARNING
                                1722           report "NUMERIC_STD."">="": metavalue detected, returning FALSE"
                                1723           severity warning;
                                1724         return false;
                                1725       end if;
                                1726       
           0 implicit_else      1720       if (L01(L01'left) = 'X') then
                                1721         
           0 if                 1726                                               return 0 > R;
                                1727       end if;
                                1728       
           0 implicit_else      1726       if UNSIGNED_NUM_BITS(R) > L'length then 
           0 reconvergence      1728       return not UNSIGNED_LESS(L01, TO_UNSIGNED(R, L01'length));
                                1729     end function ">="
           0 if                 1738         assert NO_WARNING
                                1739           report "NUMERIC_STD."">="": null argument detected, returning FALSE"
                                1740           severity warning;
                                1741         return false;
                                1742       end if;
                                1743       
           0 implicit_else      1737       if (L'length < 1) then
                                1738         
           0 reconvergence      1743       L01 := TO_01(XL, 'X');
                                1744       
           0 if                 1745         assert NO_WARNING
                                1746           report "NUMERIC_STD."">="": metavalue detected, returning FALSE"
                                1747           severity warning;
                                1748         return false;
                                1749       end if;
                                1750       
           0 implicit_else      1744       if (L01(L01'left) = 'X') then
                                1745         
           0 if                 1750                                             return 0 > R;
                                1751       end if;
                                1752       
           0 implicit_else      1750       if SIGNED_NUM_BITS(R) > L'length then 
           0 reconvergence      1752       return not SIGNED_LESS(L01, TO_SIGNED(R, L01'length));
                                1753     end function ">="
           0 if                 1768         assert NO_WARNING
                                1769           report "NUMERIC_STD.""="": null argument detected, returning FALSE"
                                1770           severity warning;
                                1771         return false;
                                1772       end if;
                                1773       
           0 implicit_else      1767       if ((L'length < 1) or (R'length < 1)) then
                                1768         
           0 reconvergence      1773       L01 := TO_01(XL, 'X');
                                1774       R01 := TO_01(XR, 'X');
                                1775       
           0 if                 1776         assert NO_WARNING
                                1777           report "NUMERIC_STD.""="": metavalue detected, returning FALSE"
                                1778           severity warning;
                                1779         return false;
                                1780       end if;
                                1781       
           0 implicit_else      1775       if ((L01(L01'left) = 'X') or (R01(R01'left) = 'X')) then
                                1776         
           0 reconvergence      1781       return UNSIGNED_EQUAL(RESIZE(L01, SIZE), RESIZE(R01, SIZE));
                                1782     end function "="
          25 if                 1795         assert NO_WARNING
                                1796           report "NUMERIC_STD.""="": null argument detected, returning FALSE"
                                1797           severity warning;
                                1798         return false;
                                1799       end if;
                                1800       
           0 implicit_else      1794       if ((L'length < 1) or (R'length < 1)) then
                                1795         
           0 reconvergence      1800       L01 := TO_01(XL, 'X');
                                1801       R01 := TO_01(XR, 'X');
                                1802       
           0 if                 1803         assert NO_WARNING
                                1804           report "NUMERIC_STD.""="": metavalue detected, returning FALSE"
                                1805           severity warning;
                                1806         return false;
                                1807       end if;
                                1808       
           0 implicit_else      1802       if ((L01(L01'left) = 'X') or (R01(R01'left) = 'X')) then
                                1803         
           0 reconvergence      1808       return SIGNED_EQUAL(RESIZE(L01, SIZE), RESIZE(R01, SIZE));
                                1809     end function "="
           0 if                 1818         assert NO_WARNING
                                1819           report "NUMERIC_STD.""="": null argument detected, returning FALSE"
                                1820           severity warning;
                                1821         return false;
                                1822       end if;
                                1823       
           0 implicit_else      1817       if (R'length < 1) then
                                1818         
           0 reconvergence      1823       R01 := TO_01(XR, 'X');
                                1824       
           0 if                 1825         assert NO_WARNING
                                1826           report "NUMERIC_STD.""="": metavalue detected, returning FALSE"
                                1827           severity warning;
                                1828         return false;
                                1829       end if;
                                1830       
           0 implicit_else      1824       if (R01(R01'left) = 'X') then
                                1825         
           0 if                 1830                                               return false;
                                1831       end if;
                                1832       
           0 implicit_else      1830       if UNSIGNED_NUM_BITS(L) > R'length then 
           0 reconvergence      1832       return UNSIGNED_EQUAL(TO_UNSIGNED(L, R01'length), R01);
                                1833     end function "="
           0 if                 1842         assert NO_WARNING
                                1843           report "NUMERIC_STD.""="": null argument detected, returning FALSE"
                                1844           severity warning;
                                1845         return false;
                                1846       end if;
                                1847       
           0 implicit_else      1841       if (R'length < 1) then
                                1842         
           0 reconvergence      1847       R01 := TO_01(XR, 'X');
                                1848       
           0 if                 1849         assert NO_WARNING
                                1850           report "NUMERIC_STD.""="": metavalue detected, returning FALSE"
                                1851           severity warning;
                                1852         return false;
                                1853       end if;
                                1854       
           0 implicit_else      1848       if (R01(R01'left) = 'X') then
                                1849         
           0 if                 1854                                             return false;
                                1855       end if;
                                1856       
           0 implicit_else      1854       if SIGNED_NUM_BITS(L) > R'length then 
           0 reconvergence      1856       return SIGNED_EQUAL(TO_SIGNED(L, R01'length), R01);
                                1857     end function "="
           0 if                 1866         assert NO_WARNING
                                1867           report "NUMERIC_STD.""="": null argument detected, returning FALSE"
                                1868           severity warning;
                                1869         return false;
                                1870       end if;
                                1871       
           0 implicit_else      1865       if (L'length < 1) then
                                1866         
           0 reconvergence      1871       L01 := TO_01(XL, 'X');
                                1872       
           0 if                 1873         assert NO_WARNING
                                1874           report "NUMERIC_STD.""="": metavalue detected, returning FALSE"
                                1875           severity warning;
                                1876         return false;
                                1877       end if;
                                1878       
           0 implicit_else      1872       if (L01(L01'left) = 'X') then
                                1873         
           0 if                 1878                                               return false;
                                1879       end if;
                                1880       
           0 implicit_else      1878       if UNSIGNED_NUM_BITS(R) > L'length then 
           0 reconvergence      1880       return UNSIGNED_EQUAL(L01, TO_UNSIGNED(R, L01'length));
                                1881     end function "="
           0 if                 1890         assert NO_WARNING
                                1891           report "NUMERIC_STD.""="": null argument detected, returning FALSE"
                                1892           severity warning;
                                1893         return false;
                                1894       end if;
                                1895       
           0 implicit_else      1889       if (L'length < 1) then
                                1890         
           0 reconvergence      1895       L01 := TO_01(XL, 'X');
                                1896       
           0 if                 1897         assert NO_WARNING
                                1898           report "NUMERIC_STD.""="": metavalue detected, returning FALSE"
                                1899           severity warning;
                                1900         return false;
                                1901       end if;
                                1902       
           0 implicit_else      1896       if (L01(L01'left) = 'X') then
                                1897         
           0 if                 1902                                             return false;
                                1903       end if;
                                1904       
           0 implicit_else      1902       if SIGNED_NUM_BITS(R) > L'length then 
           0 reconvergence      1904       return SIGNED_EQUAL(L01, TO_SIGNED(R, L01'length));
                                1905     end function "="
           0 if                 1920         assert NO_WARNING
                                1921           report "NUMERIC_STD.""/="": null argument detected, returning TRUE"
                                1922           severity warning;
                                1923         return true;
                                1924       end if;
                                1925       
           0 implicit_else      1919       if ((L'length < 1) or (R'length < 1)) then
                                1920         
           0 reconvergence      1925       L01 := TO_01(XL, 'X');
                                1926       R01 := TO_01(XR, 'X');
                                1927       
           0 if                 1928         assert NO_WARNING
                                1929           report "NUMERIC_STD.""/="": metavalue detected, returning TRUE"
                                1930           severity warning;
                                1931         return true;
                                1932       end if;
                                1933       
           0 implicit_else      1927       if ((L01(L01'left) = 'X') or (R01(R01'left) = 'X')) then
                                1928         
           0 reconvergence      1933       return not(UNSIGNED_EQUAL(RESIZE(L01, SIZE), RESIZE(R01, SIZE)));
                                1934     end function "/="
          50 if                 1947         assert NO_WARNING
                                1948           report "NUMERIC_STD.""/="": null argument detected, returning TRUE"
                                1949           severity warning;
                                1950         return true;
                                1951       end if;
                                1952       
           0 implicit_else      1946       if ((L'length < 1) or (R'length < 1)) then
                                1947         
           0 reconvergence      1952       L01 := TO_01(XL, 'X');
                                1953       R01 := TO_01(XR, 'X');
                                1954       
           0 if                 1955         assert NO_WARNING
                                1956           report "NUMERIC_STD.""/="": metavalue detected, returning TRUE"
                                1957           severity warning;
                                1958         return true;
                                1959       end if;
                                1960       
           0 implicit_else      1954       if ((L01(L01'left) = 'X') or (R01(R01'left) = 'X')) then
                                1955         
           0 reconvergence      1960       return not(SIGNED_EQUAL(RESIZE(L01, SIZE), RESIZE(R01, SIZE)));
                                1961     end function "/="
           0 if                 1970         assert NO_WARNING
                                1971           report "NUMERIC_STD.""/="": null argument detected, returning TRUE"
                                1972           severity warning;
                                1973         return true;
                                1974       end if;
                                1975       
           0 implicit_else      1969       if (R'length < 1) then
                                1970         
           0 reconvergence      1975       R01 := TO_01(XR, 'X');
                                1976       
           0 if                 1977         assert NO_WARNING
                                1978           report "NUMERIC_STD.""/="": metavalue detected, returning TRUE"
                                1979           severity warning;
                                1980         return true;
                                1981       end if;
                                1982       
           0 implicit_else      1976       if (R01(R01'left) = 'X') then
                                1977         
           0 if                 1982                                               return true;
                                1983       end if;
                                1984       
           0 implicit_else      1982       if UNSIGNED_NUM_BITS(L) > R'length then 
           0 reconvergence      1984       return not(UNSIGNED_EQUAL(TO_UNSIGNED(L, R01'length), R01));
                                1985     end function "/="
           0 if                 1994         assert NO_WARNING
                                1995           report "NUMERIC_STD.""/="": null argument detected, returning TRUE"
                                1996           severity warning;
                                1997         return true;
                                1998       end if;
                                1999       
           0 implicit_else      1993       if (R'length < 1) then
                                1994         
           0 reconvergence      1999       R01 := TO_01(XR, 'X');
                                2000       
           0 if                 2001         assert NO_WARNING
                                2002           report "NUMERIC_STD.""/="": metavalue detected, returning TRUE"
                                2003           severity warning;
                                2004         return true;
                                2005       end if;
                                2006       
           0 implicit_else      2000       if (R01(R01'left) = 'X') then
                                2001         
           0 if                 2006                                             return true;
                                2007       end if;
                                2008       
           0 implicit_else      2006       if SIGNED_NUM_BITS(L) > R'length then 
           0 reconvergence      2008       return not(SIGNED_EQUAL(TO_SIGNED(L, R01'length), R01));
                                2009     end function "/="
           0 if                 2018         assert NO_WARNING
                                2019           report "NUMERIC_STD.""/="": null argument detected, returning TRUE"
                                2020           severity warning;
                                2021         return true;
                                2022       end if;
                                2023       
           0 implicit_else      2017       if (L'length < 1) then
                                2018         
           0 reconvergence      2023       L01 := TO_01(XL, 'X');
                                2024       
           0 if                 2025         assert NO_WARNING
                                2026           report "NUMERIC_STD.""/="": metavalue detected, returning TRUE"
                                2027           severity warning;
                                2028         return true;
                                2029       end if;
                                2030       
           0 implicit_else      2024       if (L01(L01'left) = 'X') then
                                2025         
           0 if                 2030                                               return true;
                                2031       end if;
                                2032       
           0 implicit_else      2030       if UNSIGNED_NUM_BITS(R) > L'length then 
           0 reconvergence      2032       return not(UNSIGNED_EQUAL(L01, TO_UNSIGNED(R, L01'length)));
                                2033     end function "/="
           0 if                 2042         assert NO_WARNING
                                2043           report "NUMERIC_STD.""/="": null argument detected, returning TRUE"
                                2044           severity warning;
                                2045         return true;
                                2046       end if;
                                2047       
           0 implicit_else      2041       if (L'length < 1) then
                                2042         
           0 reconvergence      2047       L01 := TO_01(XL, 'X');
                                2048       
           0 if                 2049         assert NO_WARNING
                                2050           report "NUMERIC_STD.""/="": metavalue detected, returning TRUE"
                                2051           severity warning;
                                2052         return true;
                                2053       end if;
                                2054       
           0 implicit_else      2048       if (L01(L01'left) = 'X') then
                                2049         
           0 if                 2054                                             return true;
                                2055       end if;
                                2056       
           0 implicit_else      2054       if SIGNED_NUM_BITS(R) > L'length then 
           0 reconvergence      2056       return not(SIGNED_EQUAL(L01, TO_SIGNED(R, L01'length)));
                                2057     end function "/="
           0 if                 2067                                                  return NAU;
                                2068       end if;
                                2069       
           0 implicit_else      2067       if ((L'length < 1) or (R'length < 1)) then 
           0 reconvergence      2069       L01 := TO_01(RESIZE(L, SIZE), 'X');
                                2070       
           0 if                 2070                                     return L01;
                                2071       end if;
                                2072       
           0 implicit_else      2070       if (L01(L01'left) = 'X') then 
           0 reconvergence      2072       R01 := TO_01(RESIZE(R, SIZE), 'X');
                                2073       
           0 if                 2073                                     return R01;
                                2074       end if;
                                2075       
           0 implicit_else      2073       if (R01(R01'left) = 'X') then 
           0 reconvergence      2075       if UNSIGNED_LESS(L01, R01) then
                                2076         
           0 if                 2076         return L01;
                                2077       else
                                2078         
           0 else               2078         return R01;
                                2079       end if;
                                2080     end function MINIMUM
           0 if                 2088                                                  return NAS;
                                2089       end if;
                                2090       
           0 implicit_else      2088       if ((L'length < 1) or (R'length < 1)) then 
           0 reconvergence      2090       L01 := TO_01(RESIZE(L, SIZE), 'X');
                                2091       
           0 if                 2091                                     return L01;
                                2092       end if;
                                2093       
           0 implicit_else      2091       if (L01(L01'left) = 'X') then 
           0 reconvergence      2093       R01 := TO_01(RESIZE(R, SIZE), 'X');
                                2094       
           0 if                 2094                                     return R01;
                                2095       end if;
                                2096       
           0 implicit_else      2094       if (R01(R01'left) = 'X') then 
           0 reconvergence      2096       if SIGNED_LESS(L01, R01) then
                                2097         
           0 if                 2097         return L01;
                                2098       else
                                2099         
           0 else               2099         return R01;
                                2100       end if;
                                2101     end function MINIMUM
           0 sequence           2107       return MINIMUM(TO_UNSIGNED(L, R'length), R);
                                2108     end function MINIMUM
           0 sequence           2114       return MINIMUM(TO_SIGNED(L, R'length), R);
                                2115     end function MINIMUM
           0 sequence           2121       return MINIMUM(L, TO_UNSIGNED(R, L'length));
                                2122     end function MINIMUM
           0 sequence           2128       return MINIMUM(L, TO_SIGNED(R, L'length));
                                2129     end function MINIMUM
           0 if                 2139                                                  return NAU;
                                2140       end if;
                                2141       
           0 implicit_else      2139       if ((L'length < 1) or (R'length < 1)) then 
           0 reconvergence      2141       L01 := TO_01(RESIZE(L, SIZE), 'X');
                                2142       
           0 if                 2142                                     return L01;
                                2143       end if;
                                2144       
           0 implicit_else      2142       if (L01(L01'left) = 'X') then 
           0 reconvergence      2144       R01 := TO_01(RESIZE(R, SIZE), 'X');
                                2145       
           0 if                 2145                                     return R01;
                                2146       end if;
                                2147       
           0 implicit_else      2145       if (R01(R01'left) = 'X') then 
           0 reconvergence      2147       if UNSIGNED_LESS(L01, R01) then
                                2148         
           0 if                 2148         return R01;
                                2149       else
                                2150         
           0 else               2150         return L01;
                                2151       end if;
                                2152     end function MAXIMUM
           0 if                 2160                                                  return NAS;
                                2161       end if;
                                2162       
           0 implicit_else      2160       if ((L'length < 1) or (R'length < 1)) then 
           0 reconvergence      2162       L01 := TO_01(RESIZE(L, SIZE), 'X');
                                2163       
           0 if                 2163                                     return L01;
                                2164       end if;
                                2165       
           0 implicit_else      2163       if (L01(L01'left) = 'X') then 
           0 reconvergence      2165       R01 := TO_01(RESIZE(R, SIZE), 'X');
                                2166       
           0 if                 2166                                     return R01;
                                2167       end if;
                                2168       
           0 implicit_else      2166       if (R01(R01'left) = 'X') then 
           0 reconvergence      2168       if SIGNED_LESS(L01, R01) then
                                2169         
           0 if                 2169         return R01;
                                2170       else
                                2171         
           0 else               2171         return L01;
                                2172       end if;
                                2173     end function MAXIMUM
           0 sequence           2179       return MAXIMUM(TO_UNSIGNED(L, R'length), R);
                                2180     end function MAXIMUM
           0 sequence           2186       return MAXIMUM(TO_SIGNED(L, R'length), R);
                                2187     end function MAXIMUM
           0 sequence           2193       return MAXIMUM(L, TO_UNSIGNED(R, L'length));
                                2194     end function MAXIMUM
           0 sequence           2200       return MAXIMUM(L, TO_SIGNED(R, L'length));
                                2201     end function MAXIMUM
           0 sequence           2208       if ((L'length < 1) or (R'length < 1)) then
                                2209         
           0 if                 2209         assert NO_WARNING
                                2210           report "NUMERIC_STD.""?>"": null detected, returning X"
                                2211           severity warning;
                                2212         return 'X';
                                2213       else
                                2214         
           0 else               2214         for i in L'range loop
                                2215           
           0 reconvergence      2221         for i in R'range loop
                                2222           
           0 if                 2216             report "NUMERIC_STD.""?>"": '-' found in compare string"
                                2217               severity error;
                                2218             return 'X';
                                2219           end if;
                                2220         end loop;
                                2221         
           0 else               2215           if L(i) = '-' then
                                2216             
           0 if                 2223             report "NUMERIC_STD.""?>"": '-' found in compare string"
                                2224               severity error;
                                2225             return 'X';
                                2226           end if;
                                2227         end loop;
                                2228         
           0 implicit_else      2222           if R(i) = '-' then
                                2223             
           0 reconvergence      2228         if IS_X(L) or IS_X(R) then
                                2229           
           0 if                 2229           return 'X';
                                2230         elsif L 
           0 sequence           2230                 > R then
                                2231           
           0 elsif              2231           return '1';
                                2232         else
                                2233           
           0 else               2233           return '0';
                                2234         end if;
                                2235       end if;
                                2236     end function "?>"
           0 sequence           2241       if ((L'length < 1) or (R'length < 1)) then
                                2242         
           0 if                 2242         assert NO_WARNING
                                2243           report "NUMERIC_STD.""?>"": null detected, returning X"
                                2244           severity warning;
                                2245         return 'X';
                                2246       else
                                2247         
           0 else               2247         for i in L'range loop
                                2248           
           0 reconvergence      2254         for i in R'range loop
                                2255           
           0 if                 2249             report "NUMERIC_STD.""?>"": '-' found in compare string"
                                2250               severity error;
                                2251             return 'X';
                                2252           end if;
                                2253         end loop;
                                2254         
           0 else               2248           if L(i) = '-' then
                                2249             
           0 if                 2256             report "NUMERIC_STD.""?>"": '-' found in compare string"
                                2257               severity error;
                                2258             return 'X';
                                2259           end if;
                                2260         end loop;
                                2261         
           0 implicit_else      2255           if R(i) = '-' then
                                2256             
           0 reconvergence      2261         if IS_X(L) or IS_X(R) then
                                2262           
           0 if                 2262           return 'X';
                                2263         elsif L 
           0 sequence           2263                 > R then
                                2264           
           0 elsif              2264           return '1';
                                2265         else
                                2266           
           0 else               2266           return '0';
                                2267         end if;
                                2268       end if;
                                2269     end function "?>"
           0 sequence           2274       return TO_UNSIGNED(L, R'length) ?> R;
                                2275     end function "?>"
           0 sequence           2280       return TO_SIGNED(L, R'length) ?> R;
                                2281     end function "?>"
           0 sequence           2286       return L ?> TO_UNSIGNED(R, L'length);
                                2287     end function "?>"
           0 sequence           2292       return L ?> TO_SIGNED(R, L'length);
                                2293     end function "?>"
           0 sequence           2300       if ((L'length < 1) or (R'length < 1)) then
                                2301         
           0 if                 2301         assert NO_WARNING
                                2302           report "NUMERIC_STD.""?<"": null detected, returning X"
                                2303           severity warning;
                                2304         return 'X';
                                2305       else
                                2306         
           0 else               2306         for i in L'range loop
                                2307           
           0 reconvergence      2313         for i in R'range loop
                                2314           
           0 if                 2308             report "NUMERIC_STD.""?<"": '-' found in compare string"
                                2309               severity error;
                                2310             return 'X';
                                2311           end if;
                                2312         end loop;
                                2313         
           0 else               2307           if L(i) = '-' then
                                2308             
           0 if                 2315             report "NUMERIC_STD.""?<"": '-' found in compare string"
                                2316               severity error;
                                2317             return 'X';
                                2318           end if;
                                2319         end loop;
                                2320         
           0 implicit_else      2314           if R(i) = '-' then
                                2315             
           0 reconvergence      2320         if IS_X(L) or IS_X(R) then
                                2321           
           0 if                 2321           return 'X';
                                2322         elsif L 
           0 sequence           2322                 < R then
                                2323           
           0 elsif              2323           return '1';
                                2324         else
                                2325           
           0 else               2325           return '0';
                                2326         end if;
                                2327       end if;
                                2328     end function "?<"
           0 sequence           2333       if ((L'length < 1) or (R'length < 1)) then
                                2334         
           0 if                 2334         assert NO_WARNING
                                2335           report "NUMERIC_STD.""?<"": null detected, returning X"
                                2336           severity warning;
                                2337         return 'X';
                                2338       else
                                2339         
           0 else               2339         for i in L'range loop
                                2340           
           0 reconvergence      2346         for i in R'range loop
                                2347           
           0 if                 2341             report "NUMERIC_STD.""?<"": '-' found in compare string"
                                2342               severity error;
                                2343             return 'X';
                                2344           end if;
                                2345         end loop;
                                2346         
           0 else               2340           if L(i) = '-' then
                                2341             
           0 if                 2348             report "NUMERIC_STD.""?<"": '-' found in compare string"
                                2349               severity error;
                                2350             return 'X';
                                2351           end if;
                                2352         end loop;
                                2353         
           0 implicit_else      2347           if R(i) = '-' then
                                2348             
           0 reconvergence      2353         if IS_X(L) or IS_X(R) then
                                2354           
           0 if                 2354           return 'X';
                                2355         elsif L 
           0 sequence           2355                 < R then
                                2356           
           0 elsif              2356           return '1';
                                2357         else
                                2358           
           0 else               2358           return '0';
                                2359         end if;
                                2360       end if;
                                2361     end function "?<"
           0 sequence           2366       return TO_UNSIGNED(L, R'length) ?< R;
                                2367     end function "?<"
           0 sequence           2372       return TO_SIGNED(L, R'length) ?< R;
                                2373     end function "?<"
           0 sequence           2378       return L ?< TO_UNSIGNED(R, L'length);
                                2379     end function "?<"
           0 sequence           2384       return L ?< TO_SIGNED(R, L'length);
                                2385     end function "?<"
           0 sequence           2392       if ((L'length < 1) or (R'length < 1)) then
                                2393         
           0 if                 2393         assert NO_WARNING
                                2394           report "NUMERIC_STD.""?<="": null detected, returning X"
                                2395           severity warning;
                                2396         return 'X';
                                2397       else
                                2398         
           0 else               2398         for i in L'range loop
                                2399           
           0 reconvergence      2405         for i in R'range loop
                                2406           
           0 if                 2400             report "NUMERIC_STD.""?<="": '-' found in compare string"
                                2401               severity error;
                                2402             return 'X';
                                2403           end if;
                                2404         end loop;
                                2405         
           0 else               2399           if L(i) = '-' then
                                2400             
           0 if                 2407             report "NUMERIC_STD.""?<="": '-' found in compare string"
                                2408               severity error;
                                2409             return 'X';
                                2410           end if;
                                2411         end loop;
                                2412         
           0 implicit_else      2406           if R(i) = '-' then
                                2407             
           0 reconvergence      2412         if IS_X(L) or IS_X(R) then
                                2413           
           0 if                 2413           return 'X';
                                2414         elsif L 
           0 sequence           2414                 <= R then
                                2415           
           0 elsif              2415           return '1';
                                2416         else
                                2417           
           0 else               2417           return '0';
                                2418         end if;
                                2419       end if;
                                2420     end function "?<="
           0 sequence           2425       if ((L'length < 1) or (R'length < 1)) then
                                2426         
           0 if                 2426         assert NO_WARNING
                                2427           report "NUMERIC_STD.""?<="": null detected, returning X"
                                2428           severity warning;
                                2429         return 'X';
                                2430       else
                                2431         
           0 else               2431         for i in L'range loop
                                2432           
           0 reconvergence      2438         for i in R'range loop
                                2439           
           0 if                 2433             report "NUMERIC_STD.""?<="": '-' found in compare string"
                                2434               severity error;
                                2435             return 'X';
                                2436           end if;
                                2437         end loop;
                                2438         
           0 else               2432           if L(i) = '-' then
                                2433             
           0 if                 2440             report "NUMERIC_STD.""?<="": '-' found in compare string"
                                2441               severity error;
                                2442             return 'X';
                                2443           end if;
                                2444         end loop;
                                2445         
           0 implicit_else      2439           if R(i) = '-' then
                                2440             
           0 reconvergence      2445         if IS_X(L) or IS_X(R) then
                                2446           
           0 if                 2446           return 'X';
                                2447         elsif L 
           0 sequence           2447                 <= R then
                                2448           
           0 elsif              2448           return '1';
                                2449         else
                                2450           
           0 else               2450           return '0';
                                2451         end if;
                                2452       end if;
                                2453     end function "?<="
           0 sequence           2458       return TO_UNSIGNED(L, R'length) ?<= R;
                                2459     end function "?<="
           0 sequence           2464       return TO_SIGNED(L, R'length) ?<= R;
                                2465     end function "?<="
           0 sequence           2470       return L ?<= TO_UNSIGNED(R, L'length);
                                2471     end function "?<="
           0 sequence           2476       return L ?<= TO_SIGNED(R, L'length);
                                2477     end function "?<="
           0 sequence           2484       if ((L'length < 1) or (R'length < 1)) then
                                2485         
           0 if                 2485         assert NO_WARNING
                                2486           report "NUMERIC_STD.""?>="": null detected, returning X"
                                2487           severity warning;
                                2488         return 'X';
                                2489       else
                                2490         
           0 else               2490         for i in L'range loop
                                2491           
           0 reconvergence      2497         for i in R'range loop
                                2498           
           0 if                 2492             report "NUMERIC_STD.""?>="": '-' found in compare string"
                                2493               severity error;
                                2494             return 'X';
                                2495           end if;
                                2496         end loop;
                                2497         
           0 else               2491           if L(i) = '-' then
                                2492             
           0 if                 2499             report "NUMERIC_STD.""?>="": '-' found in compare string"
                                2500               severity error;
                                2501             return 'X';
                                2502           end if;
                                2503         end loop;
                                2504         
           0 implicit_else      2498           if R(i) = '-' then
                                2499             
           0 reconvergence      2504         if IS_X(L) or IS_X(R) then
                                2505           
           0 if                 2505           return 'X';
                                2506         elsif L 
           0 sequence           2506                 >= R then
                                2507           
           0 elsif              2507           return '1';
                                2508         else
                                2509           
           0 else               2509           return '0';
                                2510         end if;
                                2511       end if;
                                2512     end function "?>="
           0 sequence           2517       if ((L'length < 1) or (R'length < 1)) then
                                2518         
           0 if                 2518         assert NO_WARNING
                                2519           report "NUMERIC_STD.""?>="": null detected, returning X"
                                2520           severity warning;
                                2521         return 'X';
                                2522       else
                                2523         
           0 else               2523         for i in L'range loop
                                2524           
           0 reconvergence      2530         for i in R'range loop
                                2531           
           0 if                 2525             report "NUMERIC_STD.""?>="": '-' found in compare string"
                                2526               severity error;
                                2527             return 'X';
                                2528           end if;
                                2529         end loop;
                                2530         
           0 else               2524           if L(i) = '-' then
                                2525             
           0 if                 2532             report "NUMERIC_STD.""?>="": '-' found in compare string"
                                2533               severity error;
                                2534             return 'X';
                                2535           end if;
                                2536         end loop;
                                2537         
           0 implicit_else      2531           if R(i) = '-' then
                                2532             
           0 reconvergence      2537         if IS_X(L) or IS_X(R) then
                                2538           
           0 if                 2538           return 'X';
                                2539         elsif L 
           0 sequence           2539                 >= R then
                                2540           
           0 elsif              2540           return '1';
                                2541         else
                                2542           
           0 else               2542           return '0';
                                2543         end if;
                                2544       end if;
                                2545     end function "?>="
           0 sequence           2550       return TO_UNSIGNED(L, R'length) ?>= R;
                                2551     end function "?>="
           0 sequence           2556       return TO_SIGNED(L, R'length) ?>= R;
                                2557     end function "?>="
           0 sequence           2562       return L ?>= TO_UNSIGNED(R, L'length);
                                2563     end function "?>="
           0 sequence           2568       return L ?>= TO_SIGNED(R, L'length);
                                2569     end function "?>="
           0 sequence           2585       if ((L'length < 1) or (R'length < 1)) then
                                2586         
           0 if                 2586         assert NO_WARNING
                                2587           report "NUMERIC_STD.""?="": null detected, returning X"
                                2588           severity warning;
                                2589         return 'X';
                                2590       else
                                2591         
           0 else               2591         LX     := RESIZE(XL, SIZE);
                                2592         RX     := RESIZE(XR, SIZE);
                                2593         result := '1';
                                2594         for i in LX'low to LX'high loop
                                2595           
           0 loop_body          2595           result1 := LX(i) ?= RX(i);
                                2596           if result1 = 'U' then
                                2597             
           0 reconvergence      2604         return result;
                                2605       end if;
                                2606     end function "?="
           0 if                 2597             return 'U';
                                2598           elsif 
           0 sequence           2598                 result1 = 'X' or result = 'X' then
                                2599             
           0 elsif              2599             result := 'X';
                                2600           else
                                2601             
           0 else               2601             result := result and result1;
                                2602           end if;
                                2603         end loop;
                                2604         
           0 sequence           2619       if ((L'length < 1) or (R'length < 1)) then
                                2620         
           0 if                 2620         assert NO_WARNING
                                2621           report "NUMERIC_STD.""?="": null detected, returning X"
                                2622           severity warning;
                                2623         return 'X';
                                2624       else
                                2625         
           0 else               2625         LX     := RESIZE(XL, SIZE);
                                2626         RX     := RESIZE(XR, SIZE);
                                2627         result := '1';
                                2628         for i in LX'low to LX'high loop
                                2629           
           0 loop_body          2629           result1 := LX(i) ?= RX(i);
                                2630           if result1 = 'U' then
                                2631             
           0 reconvergence      2638         return result;
                                2639       end if;
                                2640     end function "?="
           0 if                 2631             return 'U';
                                2632           elsif 
           0 sequence           2632                 result1 = 'X' or result = 'X' then
                                2633             
           0 elsif              2633             result := 'X';
                                2634           else
                                2635             
           0 else               2635             result := result and result1;
                                2636           end if;
                                2637         end loop;
                                2638         
           0 sequence           2645       return TO_UNSIGNED(L, R'length) ?= R;
                                2646     end function "?="
           0 sequence           2651       return TO_SIGNED(L, R'length) ?= R;
                                2652     end function "?="
           0 sequence           2657       return L ?= TO_UNSIGNED(R, L'length);
                                2658     end function "?="
           0 sequence           2663       return L ?= TO_SIGNED(R, L'length);
                                2664     end function "?="
           0 sequence           2679       if ((L'length < 1) or (R'length < 1)) then
                                2680         
           0 if                 2680         assert NO_WARNING
                                2681           report "NUMERIC_STD.""?/="": null detected, returning X"
                                2682           severity warning;
                                2683         return 'X';
                                2684       else
                                2685         
           0 else               2685         LX     := RESIZE(XL, SIZE);
                                2686         RX     := RESIZE(XR, SIZE);
                                2687         result := '0';
                                2688         for i in LX'low to LX'high loop
                                2689           
           0 loop_body          2689           result1 := LX(i) ?/= RX(i);
                                2690           if result1 = 'U' then
                                2691             
           0 reconvergence      2698         return result;
                                2699       end if;
                                2700     end function "?/="
           0 if                 2691             return 'U';
                                2692           elsif 
           0 sequence           2692                 result1 = 'X' or result = 'X' then
                                2693             
           0 elsif              2693             result := 'X';
                                2694           else
                                2695             
           0 else               2695             result := result or result1;
                                2696           end if;
                                2697         end loop;
                                2698         
           0 sequence           2713       if ((L'length < 1) or (R'length < 1)) then
                                2714         
           0 if                 2714         assert NO_WARNING
                                2715           report "NUMERIC_STD.""?/="": null detected, returning X"
                                2716           severity warning;
                                2717         return 'X';
                                2718       else
                                2719         
           0 else               2719         LX     := RESIZE(XL, SIZE);
                                2720         RX     := RESIZE(XR, SIZE);
                                2721         result := '0';
                                2722         for i in LX'low to LX'high loop
                                2723           
           0 loop_body          2723           result1 := LX(i) ?/= RX(i);
                                2724           if result1 = 'U' then
                                2725             
           0 reconvergence      2732         return result;
                                2733       end if;
                                2734     end function "?/="
           0 if                 2725             return 'U';
                                2726           elsif 
           0 sequence           2726                 result1 = 'X' or result = 'X' then
                                2727             
           0 elsif              2727             result := 'X';
                                2728           else
                                2729             
           0 else               2729             result := result or result1;
                                2730           end if;
                                2731         end loop;
                                2732         
           0 sequence           2739       return TO_UNSIGNED(L, R'length) ?/= R;
                                2740     end function "?/="
           0 sequence           2745       return TO_SIGNED(L, R'length) ?/= R;
                                2746     end function "?/="
           0 sequence           2751       return L ?/= TO_UNSIGNED(R, L'length);
                                2752     end function "?/="
           0 sequence           2757       return L ?/= TO_SIGNED(R, L'length);
                                2758     end function "?/="
           0 if                 2766                                return NAU;
                                2767       end if;
                                2768       
           0 implicit_else      2766       if (ARG'length < 1) then 
           0 reconvergence      2768       return UNRESOLVED_UNSIGNED(XSLL(STD_ULOGIC_VECTOR(ARG), COUNT));
                                2769     end function SHIFT_LEFT
           0 if                 2775                                return NAU;
                                2776       end if;
                                2777       
           0 implicit_else      2775       if (ARG'length < 1) then 
           0 reconvergence      2777       return UNRESOLVED_UNSIGNED(XSRL(STD_ULOGIC_VECTOR(ARG), COUNT));
                                2778     end function SHIFT_RIGHT
           0 if                 2784                                return NAS;
                                2785       end if;
                                2786       
           0 implicit_else      2784       if (ARG'length < 1) then 
           0 reconvergence      2786       return UNRESOLVED_SIGNED(XSLL(STD_ULOGIC_VECTOR(ARG), COUNT));
                                2787     end function SHIFT_LEFT
           0 if                 2793                                return NAS;
                                2794       end if;
                                2795       
           0 implicit_else      2793       if (ARG'length < 1) then 
           0 reconvergence      2795       return UNRESOLVED_SIGNED(XSRA(STD_ULOGIC_VECTOR(ARG), COUNT));
                                2796     end function SHIFT_RIGHT
           0 if                 2804                                return NAU;
                                2805       end if;
                                2806       
           0 implicit_else      2804       if (ARG'length < 1) then 
           0 reconvergence      2806       return UNRESOLVED_UNSIGNED(XROL(STD_ULOGIC_VECTOR(ARG), COUNT));
                                2807     end function ROTATE_LEFT
           0 if                 2813                                return NAU;
                                2814       end if;
                                2815       
           0 implicit_else      2813       if (ARG'length < 1) then 
           0 reconvergence      2815       return UNRESOLVED_UNSIGNED(XROR(STD_ULOGIC_VECTOR(ARG), COUNT));
                                2816     end function ROTATE_RIGHT
           0 if                 2823                                return NAS;
                                2824       end if;
                                2825       
           0 implicit_else      2823       if (ARG'length < 1) then 
           0 reconvergence      2825       return UNRESOLVED_SIGNED(XROL(STD_ULOGIC_VECTOR(ARG), COUNT));
                                2826     end function ROTATE_LEFT
           0 if                 2832                                return NAS;
                                2833       end if;
                                2834       
           0 implicit_else      2832       if (ARG'length < 1) then 
           0 reconvergence      2834       return UNRESOLVED_SIGNED(XROR(STD_ULOGIC_VECTOR(ARG), COUNT));
                                2835     end function ROTATE_RIGHT
           0 sequence           2847       if (COUNT >= 0) then
                                2848         
           0 if                 2848         return SHIFT_LEFT(ARG, COUNT);
                                2849       else
                                2850         
           0 else               2850         return SHIFT_RIGHT(ARG, -COUNT);
                                2851       end if;
                                2852     end function "sll"
           0 sequence           2862       if (COUNT >= 0) then
                                2863         
           0 if                 2863         return SHIFT_LEFT(ARG, COUNT);
                                2864       else
                                2865         
           0 else               2865         return UNRESOLVED_SIGNED(SHIFT_RIGHT(UNRESOLVED_UNSIGNED(ARG), -COUNT));
                                2866       end if;
                                2867     end function "sll"
           0 sequence           2877       if (COUNT >= 0) then
                                2878         
           0 if                 2878         return SHIFT_RIGHT(ARG, COUNT);
                                2879       else
                                2880         
           0 else               2880         return SHIFT_LEFT(ARG, -COUNT);
                                2881       end if;
                                2882     end function "srl"
           0 sequence           2892       if (COUNT >= 0) then
                                2893         
           0 if                 2893         return UNRESOLVED_SIGNED(SHIFT_RIGHT(UNRESOLVED_UNSIGNED(ARG), COUNT));
                                2894       else
                                2895         
           0 else               2895         return SHIFT_LEFT(ARG, -COUNT);
                                2896       end if;
                                2897     end function "srl"
           0 sequence           2907       if (COUNT >= 0) then
                                2908         
           0 if                 2908         return ROTATE_LEFT(ARG, COUNT);
                                2909       else
                                2910         
           0 else               2910         return ROTATE_RIGHT(ARG, -COUNT);
                                2911       end if;
                                2912     end function "rol"
           0 sequence           2922       if (COUNT >= 0) then
                                2923         
           0 if                 2923         return ROTATE_LEFT(ARG, COUNT);
                                2924       else
                                2925         
           0 else               2925         return ROTATE_RIGHT(ARG, -COUNT);
                                2926       end if;
                                2927     end function "rol"
           0 sequence           2937       if (COUNT >= 0) then
                                2938         
           0 if                 2938         return ROTATE_RIGHT(ARG, COUNT);
                                2939       else
                                2940         
           0 else               2940         return ROTATE_LEFT(ARG, -COUNT);
                                2941       end if;
                                2942     end function "ror"
           0 sequence           2952       if (COUNT >= 0) then
                                2953         
           0 if                 2953         return ROTATE_RIGHT(ARG, COUNT);
                                2954       else
                                2955         
           0 else               2955         return ROTATE_LEFT(ARG, -COUNT);
                                2956       end if;
                                2957     end function "ror"
           0 sequence           2967       if (COUNT >= 0) then
                                2968         
           0 if                 2968         return SHIFT_LEFT(ARG, COUNT);
                                2969       else
                                2970         
           0 else               2970         return SHIFT_RIGHT(ARG, -COUNT);
                                2971       end if;
                                2972     end function "sla"
           0 sequence           2982       if (COUNT >= 0) then
                                2983         
           0 if                 2983         return SHIFT_LEFT(ARG, COUNT);
                                2984       else
                                2985         
           0 else               2985         return SHIFT_RIGHT(ARG, -COUNT);
                                2986       end if;
                                2987     end function "sla"
           0 sequence           2997       if (COUNT >= 0) then
                                2998         
           0 if                 2998         return SHIFT_RIGHT(ARG, COUNT);
                                2999       else
                                3000         
           0 else               3000         return SHIFT_LEFT(ARG, -COUNT);
                                3001       end if;
                                3002     end function "sra"
           0 sequence           3012       if (COUNT >= 0) then
                                3013         
           0 if                 3013         return SHIFT_RIGHT(ARG, COUNT);
                                3014       else
                                3015         
           0 else               3015         return SHIFT_LEFT(ARG, -COUNT);
                                3016       end if;
                                3017     end function "sra"
           0 if                 3149                              return NAS;
                                3150       end if;
                                3151       
           0 implicit_else      3149       if (NEW_SIZE < 1) then 
           0 if                 3151                                return RESULT;
                                3152       end if;
                                3153       
           0 implicit_else      3151       if (ARG'length = 0) then 
           0 reconvergence      3153       RESULT := (others => ARG(ARG'left));
                                3154       
           0 if                 3155         RESULT(BOUND downto 0) := INVEC(BOUND downto 0);
                                3156       end if;
                                3157       
           0 implicit_else      3154       if BOUND >= 0 then
                                3155         
           0 reconvergence      3157       return RESULT;
                                3158     end function RESIZE
           0 if                 3169                              return NAU;
                                3170       end if;
                                3171       
           0 implicit_else      3169       if (NEW_SIZE < 1) then 
           0 if                 3171                               return RESULT;
                                3172       end if;
                                3173       
           0 implicit_else      3171       if XARG'length = 0 then 
           0 reconvergence      3173       if (RESULT'length < ARG'length) then
                                3174         
           0 if                 3174         RESULT(RESULT'left downto 0) := XARG(RESULT'left downto 0);
                                3175       else
                                3176         
           0 else               3176         RESULT(RESULT'left downto XARG'left+1) := (others => '0');
                                3177         RESULT(XARG'left downto 0)             := XARG;
                                3178       end if;
                                3179       
           0 reconvergence      3179       return RESULT;
                                3180     end function RESIZE
           0 sequence           3185       return RESIZE (ARG      => ARG,
                                3186                      NEW_SIZE => SIZE_RES'length);
                                3187     end function RESIZE
           0 sequence           3192       return RESIZE (ARG      => ARG,
                                3193                      NEW_SIZE => SIZE_RES'length);
                                3194     end function RESIZE
           0 if                 3029         assert NO_WARNING
                                3030           report "NUMERIC_STD.TO_INTEGER: null detected, returning 0"
                                3031           severity warning;
                                3032         return 0;
                                3033       end if;
                                3034       
           0 implicit_else      3028       if (ARG'length < 1) then
                                3029         
           0 reconvergence      3034       XARG := TO_01(XXARG, 'X');
                                3035       
           0 if                 3036         assert NO_WARNING
                                3037           report "NUMERIC_STD.TO_INTEGER: metavalue detected, returning 0"
                                3038           severity warning;
                                3039         return 0;
                                3040       end if;
                                3041       
           0 implicit_else      3035       if (XARG(XARG'left) = 'X') then
                                3036         
           0 reconvergence      3041       for I in XARG'range loop
                                3042         
           0 loop_body          3042         RESULT := RESULT+RESULT;
                                3043         
           0 reconvergence      3047       return RESULT;
                                3048     end function TO_INTEGER
           0 if                 3044           RESULT := RESULT + 1;
                                3045         end if;
                                3046       end loop;
                                3047       
           0 else               3043         if XARG(I) = '1' then
                                3044           
           0 if                 3055         assert NO_WARNING
                                3056           report "NUMERIC_STD.TO_INTEGER: null detected, returning 0"
                                3057           severity warning;
                                3058         return 0;
                                3059       end if;
                                3060       
           0 implicit_else      3054       if (ARG'length < 1) then
                                3055         
           0 reconvergence      3060       XARG := TO_01(ARG, 'X');
                                3061       
           0 if                 3062         assert NO_WARNING
                                3063           report "NUMERIC_STD.TO_INTEGER: metavalue detected, returning 0"
                                3064           severity warning;
                                3065         return 0;
                                3066       end if;
                                3067       
           0 implicit_else      3061       if (XARG(XARG'left) = 'X') then
                                3062         
           0 reconvergence      3067       if XARG(XARG'left) = '0' then
                                3068         
           0 if                 3068         return TO_INTEGER(UNRESOLVED_UNSIGNED(XARG));
                                3069       else
                                3070         
           0 else               3070         return (- (TO_INTEGER(UNRESOLVED_UNSIGNED(- (XARG + 1)))) -1);
                                3071       end if;
                                3072     end function TO_INTEGER
           0 if                 3079                          return NAU;
                                3080       end if;
                                3081       
           0 implicit_else      3079       if (SIZE < 1) then 
           0 reconvergence      3081       for I in 0 to RESULT'left loop
                                3082         
           0 loop_body          3082         if (I_VAL mod 2) = 0 then
                                3083           
           0 reconvergence      3086         I_VAL          := I_VAL/2;
                                3087       end loop;
                                3088       
           0 if                 3083           RESULT(I) := '0';
                                3084         else 
           0 else               3084              RESULT(I) := '1';
                                3085         end if;
                                3086         
           0 if                 3089         assert NO_WARNING
                                3090           report "NUMERIC_STD.TO_UNSIGNED: vector truncated"
                                3091           severity warning;
                                3092       end if;
                                3093       
           0 implicit_else      3088       if not(I_VAL = 0) then
                                3089         
           0 reconvergence      3093       return RESULT;
                                3094     end function TO_UNSIGNED
           0 sequence           3102       if (SIZE < 1) then 
           0 if                 3102                          return NAS;
                                3103       end if;
                                3104       
           0 if                 3105         B_VAL := '1';
                                3106         I_VAL := -(ARG+1);
                                3107       end if;
                                3108       
           0 implicit_else      3104       if (ARG < 0) then
                                3105         
           0 reconvergence      3108       for I in 0 to RESULT'left loop
                                3109         
           0 loop_body          3109         if (I_VAL mod 2) = 0 then
                                3110           
           0 reconvergence      3114         I_VAL := I_VAL/2;
                                3115       end loop;
                                3116       
           0 if                 3110           RESULT(I) := B_VAL;
                                3111         else
                                3112           
           0 else               3112           RESULT(I) := not B_VAL;
                                3113         end if;
                                3114         
           0 if                 3117         assert NO_WARNING
                                3118           report "NUMERIC_STD.TO_SIGNED: vector truncated"
                                3119           severity warning;
                                3120       end if;
                                3121       
           0 implicit_else      3116       if ((I_VAL /= 0) or (B_VAL /= RESULT(RESULT'left))) then
                                3117         
           0 reconvergence      3121       return RESULT;
                                3122     end function TO_SIGNED
           0 sequence           3127       return TO_UNSIGNED (ARG  => ARG,
                                3128                           SIZE => SIZE_RES'length);
                                3129     end function TO_UNSIGNED
           0 sequence           3134       return TO_SIGNED (ARG  => ARG,
                                3135                         SIZE => SIZE_RES'length);
                                3136     end function TO_SIGNED
           0 sequence           3202       RESULT := UNRESOLVED_UNSIGNED(not(STD_ULOGIC_VECTOR(L)));
                                3203       return RESULT;
                                3204     end function "not"
           0 sequence           3210       RESULT := UNRESOLVED_UNSIGNED(STD_ULOGIC_VECTOR(L) and
                                3211                                     STD_ULOGIC_VECTOR(R));
                                3212       return RESULT;
                                3213     end function "and"
           0 sequence           3219       RESULT := UNRESOLVED_UNSIGNED(STD_ULOGIC_VECTOR(L) or
                                3220                                     STD_ULOGIC_VECTOR(R));
                                3221       return RESULT;
                                3222     end function "or"
           0 sequence           3228       RESULT := UNRESOLVED_UNSIGNED(STD_ULOGIC_VECTOR(L) nand
                                3229                                     STD_ULOGIC_VECTOR(R));
                                3230       return RESULT;
                                3231     end function "nand"
           0 sequence           3237       RESULT := UNRESOLVED_UNSIGNED(STD_ULOGIC_VECTOR(L) nor
                                3238                                     STD_ULOGIC_VECTOR(R));
                                3239       return RESULT;
                                3240     end function "nor"
           0 sequence           3246       RESULT := UNRESOLVED_UNSIGNED(STD_ULOGIC_VECTOR(L) xor
                                3247                                     STD_ULOGIC_VECTOR(R));
                                3248       return RESULT;
                                3249     end function "xor"
           0 sequence           3259       RESULT := UNRESOLVED_UNSIGNED(STD_ULOGIC_VECTOR(L) xnor
                                3260                                     STD_ULOGIC_VECTOR(R));
                                3261       return RESULT;
                                3262     end function "xnor"
           0 sequence           3268       RESULT := UNRESOLVED_SIGNED(not(STD_ULOGIC_VECTOR(L)));
                                3269       return RESULT;
                                3270     end function "not"
           0 sequence           3276       RESULT := UNRESOLVED_SIGNED(STD_ULOGIC_VECTOR(L) and STD_ULOGIC_VECTOR(R));
                                3277       return RESULT;
                                3278     end function "and"
           0 sequence           3284       RESULT := UNRESOLVED_SIGNED(STD_ULOGIC_VECTOR(L) or STD_ULOGIC_VECTOR(R));
                                3285       return RESULT;
                                3286     end function "or"
           0 sequence           3292       RESULT := UNRESOLVED_SIGNED(STD_ULOGIC_VECTOR(L) nand
                                3293                                   STD_ULOGIC_VECTOR(R));
                                3294       return RESULT;
                                3295     end function "nand"
           0 sequence           3301       RESULT := UNRESOLVED_SIGNED(STD_ULOGIC_VECTOR(L) nor STD_ULOGIC_VECTOR(R));
                                3302       return RESULT;
                                3303     end function "nor"
           0 sequence           3309       RESULT := UNRESOLVED_SIGNED(STD_ULOGIC_VECTOR(L) xor STD_ULOGIC_VECTOR(R));
                                3310       return RESULT;
                                3311     end function "xor"
           0 sequence           3321       RESULT := UNRESOLVED_SIGNED(STD_ULOGIC_VECTOR(L) xnor
                                3322                                   STD_ULOGIC_VECTOR(R));
                                3323       return RESULT;
                                3324     end function "xnor"
           0 sequence           3330       return UNRESOLVED_UNSIGNED (L and STD_ULOGIC_VECTOR(R));
                                3331     end function "and"
           0 sequence           3337       return UNRESOLVED_UNSIGNED (STD_ULOGIC_VECTOR(L) and R);
                                3338     end function "and"
           0 sequence           3344       return UNRESOLVED_UNSIGNED (L or STD_ULOGIC_VECTOR(R));
                                3345     end function "or"
           0 sequence           3351       return UNRESOLVED_UNSIGNED (STD_ULOGIC_VECTOR(L) or R);
                                3352     end function "or"
           0 sequence           3358       return UNRESOLVED_UNSIGNED (L nand STD_ULOGIC_VECTOR(R));
                                3359     end function "nand"
           0 sequence           3365       return UNRESOLVED_UNSIGNED (STD_ULOGIC_VECTOR(L) nand R);
                                3366     end function "nand"
           0 sequence           3372       return UNRESOLVED_UNSIGNED (L nor STD_ULOGIC_VECTOR(R));
                                3373     end function "nor"
           0 sequence           3379       return UNRESOLVED_UNSIGNED (STD_ULOGIC_VECTOR(L) nor R);
                                3380     end function "nor"
           0 sequence           3386       return UNRESOLVED_UNSIGNED (L xor STD_ULOGIC_VECTOR(R));
                                3387     end function "xor"
           0 sequence           3393       return UNRESOLVED_UNSIGNED (STD_ULOGIC_VECTOR(L) xor R);
                                3394     end function "xor"
           0 sequence           3404       return UNRESOLVED_UNSIGNED (L xnor STD_ULOGIC_VECTOR(R));
                                3405     end function "xnor"
           0 sequence           3415       return UNRESOLVED_UNSIGNED (STD_ULOGIC_VECTOR(L) xnor R);
                                3416     end function "xnor"
           0 sequence           3422       return UNRESOLVED_SIGNED (L and STD_ULOGIC_VECTOR(R));
                                3423     end function "and"
           0 sequence           3429       return UNRESOLVED_SIGNED (STD_ULOGIC_VECTOR(L) and R);
                                3430     end function "and"
           0 sequence           3436       return UNRESOLVED_SIGNED (L or STD_ULOGIC_VECTOR(R));
                                3437     end function "or"
           0 sequence           3443       return UNRESOLVED_SIGNED (STD_ULOGIC_VECTOR(L) or R);
                                3444     end function "or"
           0 sequence           3450       return UNRESOLVED_SIGNED (L nand STD_ULOGIC_VECTOR(R));
                                3451     end function "nand"
           0 sequence           3457       return UNRESOLVED_SIGNED (STD_ULOGIC_VECTOR(L) nand R);
                                3458     end function "nand"
           0 sequence           3464       return UNRESOLVED_SIGNED (L nor STD_ULOGIC_VECTOR(R));
                                3465     end function "nor"
           0 sequence           3471       return UNRESOLVED_SIGNED (STD_ULOGIC_VECTOR(L) nor R);
                                3472     end function "nor"
           0 sequence           3478       return UNRESOLVED_SIGNED (L xor STD_ULOGIC_VECTOR(R));
                                3479     end function "xor"
           0 sequence           3485       return UNRESOLVED_SIGNED (STD_ULOGIC_VECTOR(L) xor R);
                                3486     end function "xor"
           0 sequence           3496       return UNRESOLVED_SIGNED (L xnor STD_ULOGIC_VECTOR(R));
                                3497     end function "xnor"
           0 sequence           3507       return UNRESOLVED_SIGNED (STD_ULOGIC_VECTOR(L) xnor R);
                                3508     end function "xnor"
           0 sequence           3518       return and (STD_ULOGIC_VECTOR (L));
                                3519     end function "and"
           0 sequence           3540       return nand (STD_ULOGIC_VECTOR (L));
                                3541     end function "nand"
           0 sequence           3562       return or (STD_ULOGIC_VECTOR (L));
                                3563     end function "or"
           0 sequence           3584       return nor (STD_ULOGIC_VECTOR (L));
                                3585     end function "nor"
           0 sequence           3606       return xor (STD_ULOGIC_VECTOR (L));
                                3607     end function "xor"
           0 sequence           3628       return xnor (STD_ULOGIC_VECTOR (L));
                                3629     end function "xnor"
           0 sequence           3529       return and (STD_ULOGIC_VECTOR (L));
                                3530     end function "and"
           0 sequence           3551       return nand (STD_ULOGIC_VECTOR (L));
                                3552     end function "nand"
           0 sequence           3573       return or (STD_ULOGIC_VECTOR (L));
                                3574     end function "or"
           0 sequence           3595       return nor (STD_ULOGIC_VECTOR (L));
                                3596     end function "nor"
           0 sequence           3617       return xor (STD_ULOGIC_VECTOR (L));
                                3618     end function "xor"
           0 sequence           3639       return xnor (STD_ULOGIC_VECTOR (L));
                                3640     end function "xnor"
           0 sequence           3666       return MATCH_TABLE(L, R);
                                3667     end function STD_MATCH
           0 if                 3675         assert NO_WARNING
                                3676           report "NUMERIC_STD.STD_MATCH: null detected, returning FALSE"
                                3677           severity warning;
                                3678         return false;
                                3679       end if;
                                3680       
           0 implicit_else      3674       if ((L'length < 1) or (R'length < 1)) then
                                3675         
           0 reconvergence      3680       if LV'length /= RV'length then
                                3681         
           0 if                 3681         assert NO_WARNING
                                3682           report "NUMERIC_STD.STD_MATCH: L'LENGTH /= R'LENGTH, returning FALSE"
                                3683           severity warning;
                                3684         return false;
                                3685       else
                                3686         
           0 else               3686         for I in LV'low to LV'high loop
                                3687           
           0 reconvergence      3691         return true;
                                3692       end if;
                                3693     end function STD_MATCH
           0 if                 3688             return false;
                                3689           end if;
                                3690         end loop;
                                3691         
           0 else               3687           if not (MATCH_TABLE(LV(I), RV(I))) then
                                3688             
           0 if                 3701         assert NO_WARNING
                                3702           report "NUMERIC_STD.STD_MATCH: null detected, returning FALSE"
                                3703           severity warning;
                                3704         return false;
                                3705       end if;
                                3706       
           0 implicit_else      3700       if ((L'length < 1) or (R'length < 1)) then
                                3701         
           0 reconvergence      3706       if LV'length /= RV'length then
                                3707         
           0 if                 3707         assert NO_WARNING
                                3708           report "NUMERIC_STD.STD_MATCH: L'LENGTH /= R'LENGTH, returning FALSE"
                                3709           severity warning;
                                3710         return false;
                                3711       else
                                3712         
           0 else               3712         for I in LV'low to LV'high loop
                                3713           
           0 reconvergence      3717         return true;
                                3718       end if;
                                3719     end function STD_MATCH
           0 if                 3714             return false;
                                3715           end if;
                                3716         end loop;
                                3717         
           0 else               3713           if not (MATCH_TABLE(LV(I), RV(I))) then
                                3714             
           0 if                 3727         assert NO_WARNING
                                3728           report "NUMERIC_STD.STD_MATCH: null detected, returning FALSE"
                                3729           severity warning;
                                3730         return false;
                                3731       end if;
                                3732       
           0 implicit_else      3726       if ((L'length < 1) or (R'length < 1)) then
                                3727         
           0 reconvergence      3732       if LV'length /= RV'length then
                                3733         
           0 if                 3733         assert NO_WARNING
                                3734           report "NUMERIC_STD.STD_MATCH: L'LENGTH /= R'LENGTH, returning FALSE"
                                3735           severity warning;
                                3736         return false;
                                3737       else
                                3738         
           0 else               3738         for I in LV'low to LV'high loop
                                3739           
           0 reconvergence      3743         return true;
                                3744       end if;
                                3745     end function STD_MATCH
           0 if                 3740             return false;
                                3741           end if;
                                3742         end loop;
                                3743         
           0 else               3739           if not (MATCH_TABLE(LV(I), RV(I))) then
                                3740             
           0 if                 3759         assert NO_WARNING
                                3760           report "NUMERIC_STD.TO_01: null detected, returning NAU"
                                3761           severity warning;
                                3762         return NAU;
                                3763       end if;
                                3764       
           0 implicit_else      3758       if (S'length < 1) then
                                3759         
           0 reconvergence      3764       return UNRESOLVED_UNSIGNED(TO_01(STD_ULOGIC_VECTOR(S), XMAP));
                                3765     end function TO_01
           0 if                 3772         assert NO_WARNING
                                3773           report "NUMERIC_STD.TO_01: null detected, returning NAS"
                                3774           severity warning;
                                3775         return NAS;
                                3776       end if;
                                3777       
          25 implicit_else      3771       if (S'length < 1) then
                                3772         
          25 reconvergence      3777       return UNRESOLVED_SIGNED(TO_01(STD_ULOGIC_VECTOR(S), XMAP));
                                3778     end function TO_01
           0 sequence           3783       return UNRESOLVED_UNSIGNED(TO_X01(STD_ULOGIC_VECTOR(S)));
                                3784     end function TO_X01
           0 sequence           3789       return UNRESOLVED_SIGNED(TO_X01(STD_ULOGIC_VECTOR(S)));
                                3790     end function TO_X01
           0 sequence           3795       return UNRESOLVED_UNSIGNED(TO_X01Z(STD_ULOGIC_VECTOR(S)));
                                3796     end function TO_X01Z
           0 sequence           3801       return UNRESOLVED_SIGNED(TO_X01Z(STD_ULOGIC_VECTOR(S)));
                                3802     end function TO_X01Z
           0 sequence           3807       return UNRESOLVED_UNSIGNED(TO_UX01(STD_ULOGIC_VECTOR(S)));
                                3808     end function TO_UX01
           0 sequence           3813       return UNRESOLVED_SIGNED(TO_UX01(STD_ULOGIC_VECTOR(S)));
                                3814     end function TO_UX01
           0 sequence           3819       return IS_X(STD_ULOGIC_VECTOR(S));
                                3820     end function IS_X
           0 sequence           3825       return IS_X(STD_ULOGIC_VECTOR(S));
                                3826     end function IS_X
           0 sequence           3833       return TO_OSTRING(STD_ULOGIC_VECTOR (value));
                                3834     end function TO_OSTRING
           0 sequence           3842       return TO_OSTRING(pad & STD_ULOGIC_VECTOR (value));
                                3843     end function TO_OSTRING
           0 sequence           3847       return to_hstring(STD_ULOGIC_VECTOR (value));
                                3848     end function to_hstring
           0 sequence           3856       return to_hstring(pad & STD_ULOGIC_VECTOR (value));
                                3857     end function to_hstring
           0 sequence           3863       READ (L     => L,
                                3864             VALUE => ivalue,
                                3865             GOOD  => GOOD);
                                3866       VALUE := UNSIGNED(ivalue);
                                3867     end procedure READ
           0 sequence           3872       READ (L      => L,
                                3873              VALUE => ivalue);
                                3874       VALUE := UNSIGNED (ivalue);
                                3875     end procedure READ
           0 sequence           3881       READ (L     => L,
                                3882             VALUE => ivalue,
                                3883             GOOD  => GOOD);
                                3884       VALUE := SIGNED(ivalue);
                                3885     end procedure READ
           0 sequence           3890       READ (L      => L,
                                3891              VALUE => ivalue);
                                3892       VALUE := SIGNED (ivalue);
                                3893     end procedure READ
           0 sequence           3899       ivalue := STD_ULOGIC_VECTOR (VALUE);
                                3900       WRITE (L          => L,
                                3901               VALUE     => ivalue,
                                3902               JUSTIFIED => JUSTIFIED,
                                3903               FIELD     => FIELD);
                                3904     end procedure WRITE
           0 sequence           3910       ivalue := STD_ULOGIC_VECTOR (VALUE);
                                3911       WRITE (L          => L,
                                3912               VALUE     => ivalue,
                                3913               JUSTIFIED => JUSTIFIED,
                                3914               FIELD     => FIELD);
                                3915     end procedure WRITE
           0 sequence           3921       OREAD (L     => L,
                                3922              VALUE => ivalue,
                                3923              GOOD  => GOOD);
                                3924       VALUE := UNSIGNED(ivalue);
                                3925     end procedure OREAD
           0 sequence           3935       OREAD (L      => L,
                                3936               VALUE => ivalue,            -- Read padded STRING
                                3937               GOOD  => ok);
                                3938       -- Bail out if there was a bad read
                                3939       
           0 if                 3940         GOOD := false;
                                3941         return;
                                3942       end if;
                                3943       
           0 implicit_else      3939       if not ok then
                                3940         
           0 reconvergence      3943       expected_padding := (others => ivalue(pad));
                                3944       if ivalue(0 to pad-1) /= expected_padding then
                                3945         
           0 if                 3945         GOOD := false;
                                3946       else
                                3947         
           0 else               3947         GOOD  := true;
                                3948         VALUE := UNRESOLVED_SIGNED (ivalue (pad to ivalue'high));
                                3949       end if;
                                3950     end procedure OREAD
           0 sequence           3955       OREAD (L     => L,
                                3956              VALUE => ivalue);
                                3957       VALUE := UNSIGNED (ivalue);
                                3958     end procedure OREAD
           0 sequence           3966       OREAD (L      => L,
                                3967               VALUE => ivalue);           -- Read padded string
                                3968       expected_padding := (others => ivalue(pad));
                                3969       if ivalue(0 to pad-1) /= expected_padding then
                                3970         
           0 if                 3970         assert false
                                3971           report "NUMERIC_STD.OREAD Error: Signed vector truncated"
                                3972           severity error;
                                3973       else
                                3974         
           0 else               3974         VALUE := UNRESOLVED_SIGNED (ivalue (pad to ivalue'high));
                                3975       end if;
                                3976     end procedure OREAD
           0 sequence           3982       HREAD (L     => L,
                                3983              VALUE => ivalue,
                                3984              GOOD  => GOOD);
                                3985       VALUE := UNSIGNED(ivalue);
                                3986     end procedure HREAD
           0 sequence           3996       HREAD (L      => L,
                                3997               VALUE => ivalue,            -- Read padded STRING
                                3998               GOOD  => ok);
                                3999       
           0 if                 4000         GOOD := false;
                                4001         return;
                                4002       end if;
                                4003       
           0 implicit_else      3999       if not ok then
                                4000         
           0 reconvergence      4003       expected_padding := (others => ivalue(pad));
                                4004       if ivalue(0 to pad-1) /= expected_padding then
                                4005         
           0 if                 4005         GOOD := false;
                                4006       else
                                4007         
           0 else               4007         GOOD  := true;
                                4008         VALUE := UNRESOLVED_SIGNED (ivalue (pad to ivalue'high));
                                4009       end if;
                                4010     end procedure HREAD
           0 sequence           4015       HREAD (L     => L,
                                4016              VALUE => ivalue);
                                4017       VALUE := UNSIGNED (ivalue);
                                4018     end procedure HREAD
           0 sequence           4026       HREAD (L      => L,
                                4027               VALUE => ivalue);           -- Read padded string
                                4028       expected_padding := (others => ivalue(pad));
                                4029       if ivalue(0 to pad-1) /= expected_padding then
                                4030         
           0 if                 4030         assert false
                                4031           report "NUMERIC_STD.HREAD Error: Signed vector truncated"
                                4032           severity error;
                                4033       else
                                4034         
           0 else               4034         VALUE := UNRESOLVED_SIGNED (ivalue (pad to ivalue'high));
                                4035       end if;
                                4036     end procedure HREAD
           0 sequence           4042       ivalue := STD_ULOGIC_VECTOR (VALUE);
                                4043       OWRITE (L         => L,
                                4044               VALUE     => ivalue,
                                4045               JUSTIFIED => JUSTIFIED,
                                4046               FIELD     => FIELD);
                                4047     end procedure OWRITE
           0 sequence           4056       ivalue := STD_ULOGIC_VECTOR (VALUE);
                                4057       OWRITE (L         => L,
                                4058               VALUE     => pad & ivalue,
                                4059               JUSTIFIED => JUSTIFIED,
                                4060               FIELD     => FIELD);
                                4061     end procedure OWRITE
           0 sequence           4067       ivalue := STD_ULOGIC_VECTOR (VALUE);
                                4068       HWRITE (L         => L,
                                4069               VALUE     => ivalue,
                                4070               JUSTIFIED => JUSTIFIED,
                                4071               FIELD     => FIELD);
                                4072     end procedure HWRITE
           0 sequence           4081       ivalue := STD_ULOGIC_VECTOR (VALUE);
                                4082       HWRITE (L         => L,
                                4083               VALUE     => pad & ivalue,
                                4084               JUSTIFIED => JUSTIFIED,
                                4085               FIELD     => FIELD);
                                4086     end procedure HWRITE
           0 sequence             82       if ARG >= 0 then
                                  83         
           0 if                   83         N := ARG;
                                  84       else
                                  85         
           0 else                 85         N := -(ARG+1);
                                  86       end if;
                                  87       
           0 reconvergence        87       NBITS := 1;
                                  88       while 
           0 sequence             88             N > 0 loop
                                  89         
           0 loop_body            89         NBITS := NBITS+1;
                                  90         N := N / 2;
                                  91       end loop;
                                  92       
           0 reconvergence        92       return NBITS;
                                  93     end function SIGNED_NUM_BITS
           0 sequence             99       N := ARG;
                                 100       NBITS := 1;
                                 101       while 
           0 sequence            101             N > 1 loop
                                 102         
           0 loop_body           102         NBITS := NBITS+1;
                                 103         N := N / 2;
                                 104       end loop;
                                 105       
           0 reconvergence       105       return NBITS;
                                 106     end function UNSIGNED_NUM_BITS
           0 sequence            123       for I in 0 to L_LEFT loop
                                 124         
           0 loop_body           124         RESULT(I) := CBIT xor XL(I) xor XR(I);
                                 125         CBIT      := (CBIT and XL(I)) or (CBIT and XR(I)) or (XL(I) and XR(I));
                                 126       end loop;
                                 127       
           0 reconvergence       127       return RESULT;
                                 128     end function ADD_UNSIGNED
           0 sequence            143       for I in 0 to L_LEFT loop
                                 144         
           0 loop_body           144         RESULT(I) := CBIT xor XL(I) xor XR(I);
                                 145         CBIT      := (CBIT and XL(I)) or (CBIT and XR(I)) or (XL(I) and XR(I));
                                 146       end loop;
                                 147       
           0 reconvergence       147       return RESULT;
                                 148     end function ADD_SIGNED
           0 sequence            162       TEMP   := "0"&NUM;
                                 163       QUOT   := (others => '0');
                                 164       TOPBIT := -1;
                                 165       for J in DENOM'range loop
                                 166         
           0 if                  167           TOPBIT := J;
                                 168           exit;
                                 169         end if;
                                 170       end loop;
                                 171       
           0 blocking            171       assert TOPBIT >= 0 report "NUMERIC_STD.DIVMOD: DIV, MOD, or REM by zero"
                                 172         severity error;
                                 173   
                                 174       for J in NUM'length-(TOPBIT+1) downto 0 loop
                                 175         
           0 else                166         if DENOM(J) = '1' then
                                 167           
           0 reconvergence       180         assert TEMP(TOPBIT+J+1) = '0'
                                 181           report "NUMERIC_STD.DIVMOD: internal error in the division algorithm"
                                 182           severity error;
                                 183       end loop;
                                 184       
           0 reconvergence       184       XQUOT   := RESIZE(QUOT, XQUOT'length);
                                 185       XREMAIN := RESIZE(TEMP, XREMAIN'length);
                                 186     end procedure DIVMOD
           0 if                  176           TEMP(TOPBIT+J+1 downto J) := (TEMP(TOPBIT+J+1 downto J))
                                 177                                        -("0"&DENOM(TOPBIT downto 0));
                                 178           QUOT(J) := '1';
                                 179         end if;
                                 180         
           0 else                175         if TEMP(TOPBIT+J+1 downto J) >= "0"&DENOM(TOPBIT downto 0) then
                                 176           
           0 if                  198         RESULT(ARG_L downto COUNT) := XARG(ARG_L-COUNT downto 0);
                                 199       end if;
                                 200       
           0 implicit_else       197       if COUNT <= ARG_L then
                                 198         
           0 reconvergence       200       return RESULT;
                                 201     end function XSLL
           0 if                  211         RESULT(ARG_L-COUNT downto 0) := XARG(ARG_L downto COUNT);
                                 212       end if;
                                 213       
           0 implicit_else       210       if COUNT <= ARG_L then
                                 211         
           0 reconvergence       213       return RESULT;
                                 214     end function XSRL
           0 sequence            224       if ((ARG'length <= 1) or (XCOUNT = 0)) then 
           0 if                  224                                                   return ARG;
                                 225       else
                                 226         
           0 if                  226                                  XCOUNT           := ARG_L;
                                 227         end if;
                                 228         
           0 implicit_else       226         if (XCOUNT > ARG_L) then 
           0 reconvergence       228         RESULT(ARG_L-XCOUNT downto 0)             := XARG(ARG_L downto XCOUNT);
                                 229         RESULT(ARG_L downto (ARG_L - XCOUNT + 1)) := (others => XARG(ARG_L));
                                 230       end if;
                                 231       
           0 reconvergence       231       return RESULT;
                                 232     end function XSRA
           0 sequence            242       COUNTM := COUNT mod (ARG_L + 1);
                                 243       
           0 if                  244         RESULT(ARG_L downto COUNTM) := XARG(ARG_L-COUNTM downto 0);
                                 245         RESULT(COUNTM-1 downto 0)   := XARG(ARG_L downto ARG_L-COUNTM+1);
                                 246       end if;
                                 247       
           0 implicit_else       243       if COUNTM /= 0 then
                                 244         
           0 reconvergence       247       return RESULT;
                                 248     end function XROL
           0 sequence            258       COUNTM := COUNT mod (ARG_L + 1);
                                 259       
           0 if                  260         RESULT(ARG_L-COUNTM downto 0)       := XARG(ARG_L downto COUNTM);
                                 261         RESULT(ARG_L downto ARG_L-COUNTM+1) := XARG(COUNTM-1 downto 0);
                                 262       end if;
                                 263       
           0 implicit_else       259       if COUNTM /= 0 then
                                 260         
           0 reconvergence       263       return RESULT;
                                 264     end function XROR
           0 sequence            273       return STD_ULOGIC_VECTOR(L) = STD_ULOGIC_VECTOR(R);
                                 274     end function UNSIGNED_EQUAL
           0 sequence            281       return STD_ULOGIC_VECTOR(L) = STD_ULOGIC_VECTOR(R);
                                 282     end function SIGNED_EQUAL
           0 sequence            289       return STD_ULOGIC_VECTOR(L) < STD_ULOGIC_VECTOR(R);
                                 290     end function UNSIGNED_LESS
           0 sequence            299       INTERN_L    := L;
                                 300       INTERN_R    := R;
                                 301       INTERN_L(0) := not INTERN_L(0);
                                 302       INTERN_R(0) := not INTERN_R(0);
                                 303       return STD_ULOGIC_VECTOR(INTERN_L) < STD_ULOGIC_VECTOR(INTERN_R);
                                 304     end function SIGNED_LESS
           0 sequence            312       return STD_ULOGIC_VECTOR(L) <= STD_ULOGIC_VECTOR(R);
                                 313     end function UNSIGNED_LESS_OR_EQUAL
           0 sequence            323       INTERN_L                           := L;
                                 324       INTERN_R                           := R;
                                 325       INTERN_L(0)                        := not INTERN_L(0);
                                 326       INTERN_R(0)                        := not INTERN_R(0);
                                 327       return STD_ULOGIC_VECTOR(INTERN_L) <= STD_ULOGIC_VECTOR(INTERN_R);
                                 328     end function SIGNED_LESS_OR_EQUAL

Line coverage for $root.$pkgs.work.not_test_pkg:

Coverage for source: not_test_pkg.vhdl

